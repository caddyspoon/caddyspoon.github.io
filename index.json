[{"categories":["Dev"],"content":"표현 가능한 이진트리 문제를 풀어보려고 합니다. 프로그래머스의 2023 KAKAO BLIND RECRUITMENT 문제팩 필터를 통해 찾아볼 수 있으며, 🚀여기를 클릭하면 바로 이동할 수 있습니다. 제 코드는 가장 이상적인 해법이 아닙니다. 다만 저의 생각과 코드 작성의 방식을 공유하고자 글을 작성해봅니다.😋 ","date":"2023-01-25","objectID":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/:0:0","tags":["python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표현 가능한 이진트리 (Python)","uri":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"categories":["Dev"],"content":"문제 🚀표현 가능한 이진트리 참고 링크 | 프로그래머스의 문제를 외부에 게시할 수 있나요? ","date":"2023-01-25","objectID":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/:1:0","tags":["python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표현 가능한 이진트리 (Python)","uri":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"categories":["Dev"],"content":"풀이 ","date":"2023-01-25","objectID":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/:2:0","tags":["python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표현 가능한 이진트리 (Python)","uri":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"categories":["Dev"],"content":"1. 해결 아이디어 탐색: 변환된 십진수는 어떻게 표현될까? 포화 이진트리는 각 높이에 모든 노드들이 빼곡히 들어선 피라미드 모양의 이진트리입니다. 문제에서는 이진수로 표현된 이진트리의 경우, 비어있는 노드는 0으로, 실제 존재하는 노드는 1로 표기하고 있음을 밝히고 있습니다. 문제에서 주어진 numbers 배열의 숫자의 경우 이진수로 변환했을 때, 앞 자리에 얼마 만큼의 0이 존재하는지 알 수 없습니다. 문제에서 예시로 든 42를 예로 들어볼까요? 42를 이진수로 표현하면 101010입니다. 해당 수는 이진트리로 표현할 수 있다는 것을 문제에서 알려주고 있고 그 형태는 다음과 같습니다. 111의 트리 노드의 형태를 보고 직관적으로 이진수로 표현하면 111로 나타나는 트리입니다. 10진수로 나타내면 7에 해당하는 트리네요. 다시 42, 이진수 101010으로 돌아와 생각해 보겠습니다. 42는 이진트리로 나타낼 경우에 0101010이며 그림으로 나타나면 다음과 같이 나타낼 수 있습니다. 손으로 그렸는데 깔끔하지 않게 됐어요. 그래서 귀엽기라도 해보자했습니다. 나쁘지 않네요. 낫 밷. 회색 웃는 점들이 비어있는 노드들입니다. 그림처럼 비어있는 노드를 추가하니 111로만 표현될 것만 같았던 트리가 다른 방식으로도 표현됐습니다. 지금은 0101010이네요. 네, 우리에게 익숙한 10진수로는 42입니다. 우주의 진리인 수인 만큼 트리 모양도 아름답네요. 여기에 빈 노드들로만 이루어진 한 층을 추가해도 트리가 만들 수 있지 않을까요? 자유민주주의 대한민국에서 안될 것 없죠. 해보죠, 까짓 거. 이렇게 만들어진 트리는 000100010001000으로 나타낼 수 있습니다. 십진수로는 2184에 해당하는 숫자입니다. 이를 통해 우리가 알 수 있는 것은, 같은 모양의 트리도 다른 수를 나타낼 수 있다는 것입니다. 여기서 하나의 의문이 생기는데요, ‘’그렇다면 이진수로 변환된 수의 앞에 몇 개의 0을 붙여야 비어있는 노드가 포함된 트리 표현수가 될까?‘입니다. 발견: 포화 이진 트리로 표현하기 위의 시행에서 알아낸 사실이 있습니다. 이진수로 표현된 해당 십진수를 트리로 그리게 되면 그 형태는 포화 이진 트리로 만들어진다는 사실이죠. 해당 형태의 포화 이진 트리를 만들고, 비어있는 자식 노드를 0으로 바꾸게 되면 해당 숫자를 알아낼 수 있습니다. 달리 생각하면, 포화 이진트리를 통해 비어있는 노드가 포함된 트리를 구성할 수 있고, 이진수에서 가장 앞자리에 등장하는 1 앞에 등장하는 0의 갯수도 알 수 있다는 의미이죠. 다음의 이진 트리는 1111111입니다. 42의 이진트리 표현 수인 0101010에서 비어있던 모든 노드를 채워놓은 형태로 볼 수 있겠네요. 42는 101010으로 바꾸어지며 여섯 자리의 2진수로 나타나게 된다는 것을 알 수 있습니다. 3층 짜리 이진 포화트리에서 뭔가가 부족한 트리라는 것을 우리는 확인할 수 있었죠. 이와 같이 십진수의 해당 숫자를 2진수로 바꾸면 지금 몇 개의 노드로 이루어진 트리인지 알 수 있게 되고, 해당 노드 갯수보다 큰 포화이진트리 중에 가장 가까운 포화이진트리가 목표 숫자의 형태로 만들 수 있는 포화 이진 트리임을 알 수 있습니다. 그럼 가장 가까운 포화 이진 트리는 어떻게 알 수 있을까요? 그건 지금까지 직접 그려본 결과 노드의 숫자를 보면 알 수 있었죠. 그리고 포화 이진 트리는 높이 h에 대해 2^(h + 1) - 1개의 노드 갯수를 가집니다. 2층 짜리 포화 이진 트리는 3개, 3층 짜리 포화 이진 트리는 7개, … 5층 짜리 이진트리는 63개의 노드 갯수를 가지게 될 것입니다. 포화 정 이진 트리에서, 다. 따라서, 이다. (l은 리프 노드의 갯수를 의미한다.) 출처: 위키피디아, “이진 트리” 지금까지 예를 들었던 42로 다시 이 과정을 정리하면 42로 이진트리를 만들 수 있을까? -\u003e 이진수로 변환해보자 -\u003e 101010이란 값을 얻었다! -\u003e 현재 노드의 갯수는 6개, 1앞에 필요한 0의 갯수? -\u003e 가장 가까운 포화 이진 트리의 노드 갯수를 통해 알 수 있었지 -\u003e 42의 노드 갯수 6은 3(= 2^2 - 1)보다는 크지만 7(= 2^3 - 1) 보다는 작다! -\u003e 즉 7개 노드로 이루어진 포화 이진 트리 1111111이 42가 그려질 트리의 형태이고 노드 한 개가 부족하니까 42는 0101010으로 나타낼 수 있다! 다음과 같은 과정을 통해 0까지 포함된, 즉 비어있는 노드까지 포함된 42가 나타낼 이진 트리의 형태를 알아낼 수 있습니다. 통합: 가공한 자료를 통해 문제 해결하기 자 이제 십진수를 0까지 포함된 트리 표현식으로 해결할 수 있으니, 문제를 해결할 수 있습니다. 이제 주어진 이진 표현식으로 판별만 하면 되는데, 해당 트리 표현수가 실제 유효한 트리인 것은 어떻게 알 수 있을까요? 간단합니다. 예시에서 나타났듯, 자식 노드가 부모 노드가 존재할 때 존재하면 됩니다. 그림으로 나타내면 간단한 이야기입니다. 가령 5, 이진수로 나타냈을 때 101은 이진 트리로 나타낼 수 없습니다. 트리가 가내수공업이라 좀 찌그러졌는데 이해해주세요.😘 다음과 같이 부모는 없지만 자식이 있는 형태이기 때문입니다. 부모 없는 자식이 있을 수 없죠. 뭔가 패륜적 언사 같은데 오해하지 말고 들어주세요. 트리는 부모가 있어야 자식이 존재할 수 있습니다. 따라서 부모 노드 없는 자식노드로 이루어진 트리란 존재할 수 없습니다. 101로 나타내는 트리 형태는 부모 없이 자식들로만 이루어진 트리이기 때문에 존재할 수 없습니다. 자 그럼 이런 형태인지 아닌지만 판별해주면 되겠네요. 어떻게 하면 될까요? 바로 이 작업을 해주기 위해 0이 표시된 정 이진 트리로 만들기 위해 애썼던 것이죠. 다시 42를 가져와서 설명을 하자면, 현재 트리의 최상단 노드, 즉 루트 노드는 트리 표현수의 가장 중앙에 위치하는 수입니다. 0101010에서 루트노드는 네 번째 1입니다. 0101010에서의 까맣게 칠해진 1이죠. 이와 같은 작업을 반복해줍니다. 0101010에서 가장 루트 노드 1(0101010)은 부모와 자식이 이루어지는 = 자식이 있으며 부모가 존재하는 노드입니다. 그림에서 보여주는 빨간색 부분이 트리가 가능함을 확인했고, 그 아래 존재하는 노란 자식들이 부모가 존재하는, 존재할 수 있는 트리임을 확인했습니다. 이것을 반복해줍니다. 이제 010 [1] 010으로 쪼개어, 자식 트리들도 트리로 만들어지는 봅니다. 010 [1] 010에서 [1] 왼쪽의 010은 아래 그림의 A트리가 될 것이고, 오른쪽 010은 B 트리가 될 것입니다. 공교롭게도 두 자식 트리 모두 010이네요. 부모가 존재하고 자식이 비어있는 구조입니다. 자식은 비어있어도 상관없습니다. 부모가 있다면 말이지요. 하지만 반대로 부모가 존재하지 않는데, 자식이 존재하면 안됩니다. 101(=십진수 5)와 같은 형태가 있으면 안되죠. 따라서 순차적으로 해당 이진트리를 표현하는 수의 중앙이 1이며, 자식 트리를 분리한 뒤 자식 트리를 다시 부모노드가 존재하는 트리인지 판별하는 과정을 반복해주면 됩니다. 또, 부모노드가 존재하지 않는데 자식 노드가 존재하는지 확인을 해주면 되겠습니다. 리프 노드에 닿을 때까지요. 전형적인 분할정복 방식의 코드가 될 것 같네요. ","date":"2023-01-25","objectID":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/:2:1","tags":["python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표현 가능한 이진트리 (Python)","uri":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"categories":["Dev"],"content":"2. 코드 1. 십진수를 이진수로 변환하기 위에서 이야기한대로 코드를 짜보겠습니다. 다음 함수는 십진수를 비어있는 0까지 모두 표현된 이진수(: sting)를 반환할 것입니다. # 현재 수 이진 값으로 만들기 def conv_to_bintree(num): # 이진 값으로 변환된 수 target_num = bin(num)[2:] # 노드개수 node_cnt = len(target_num) # 가장 가까운 포화 이진 트리 찾기 # 다음은 2의 지수가 될 변수 # 'exp' stands for exponential exp = 0 # (2의 제곱수 - 1)는 이진트리로 변환 했을 때 포화 이진 트리가 된다. # 가령 (2**2 - 1 = 3)의 경우 2층 포화 이진 트리, (2**3 - 1 = 7)의 경우 3층 포화 이진 트리가 된다. # 그러므로 현재 값보다 큰 가장 가까운 2의 제곱수로 만든 이진트리가 자식 노드가 몇 개 비워진 이진트리가 된다. while True: # 현재 값을 넘는 가장 가까운 2의 제곱 수인 경우 if node_cnt \u003c 2 ** exp: # 비어진 말단 최하단이자 최좌단의 노드 경우 0을 채워준다. # .zfill()의 자세한 설명은 아래 링크에 return target_num.zfill(2 ** exp - 1) # 목표가 되는 수가 2**지수 보다 작을 경우 지수를 하나 더해줌 else: exp += 1 참고) 자릿수에 맞게 string에 0 채우는 메소드; str.zfill() 2. 이진트리 표현수가 유효한 트리 표현 방식인지 판별 이제 이진수로 표현된 수를 가지고 유효한 트리로 만들어지는 확인해봅시다. def verdict(target_num): stack = [target_num] while stack: num = stack.pop() # 현재 노드의 길이가 2보다 작으면 리프 노드 if len(num) \u003c= 2: continue # 현재 이진수로 표현된 트리의 가운데 값이 최상단 부모 노드 parent_node = len(num) // 2 # 부모노드가 0인데 자식노드가 존재하는 경우 -\u003e 트리로 표현되지 않는 표현식 # 따라서 이진 트리로 만들 수 없다고 판별하여 0을 반환 if (num[parent_node]) == '0' and '1' in num: return 0 # 현재 이진트리를 반으로 쪼개서 왼쪽 트리를 스택에 넣기 stack.append(num[:parent_node]) # 오른쪽 트리를 스택에 넣기 stack.append(num[parent_node + 1:]) # 순회가 끝난 경우 완성할 수 있는 트리이므로 1을 반환 return 1 다음의 큰 두 가지 아이디어로 해결할 수 있는 문제였습니다. 전체 코드를 구성하면 다음과 같습니다. 문제 해결 코드 # 현재 수 이진 값으로 만들기 def conv_to_bintree(num): # 이진 값으로 변환된 수 target_num = bin(num)[2:] # 노드개수 node_cnt = len(target_num) # 가장 가까운 포화 이진 트리 찾기 # 다음은 2의 지수가 될 변수 # 'exp' stands for exponential exp = 0 # (2의 제곱수 - 1)는 이진트리로 변환 했을 때 포화 이진 트리가 된다. # 가령 (2**2 - 1 = 3)의 경우 2층 포화 이진 트리, (2**3 - 1 = 7)의 경우 3층 포화 이진 트리가 된다. # 그러므로 현재 값보다 큰 가장 가까운 2의 제곱수로 만든 이진트리가 자식 노드가 몇 개 비워진 이진트리가 된다. while True: # 현재 값을 넘는 가장 가까운 2의 제곱 수인 경우 if node_cnt \u003c 2 ** exp: # 비어진 말단 최하단이자 최좌단의 노드 경우 0을 채워준다. return target_num.zfill(2 ** exp - 1) # 목표가 되는 수가 2**지수 보다 작을 경우 지수를 하나 더해줌 else: exp += 1 def verdict(target_num): stack = [target_num] while stack: num = stack.pop() # 현재 노드의 길이가 2보다 작으면 리프 노드 if len(num) \u003c= 2: continue # 현재 이진수로 표현된 트리의 가운데 값이 최상단 부모 노드 parent_node = len(num) // 2 # 부모노드가 0인데 자식노드가 존재하는 경우 -\u003e 트리로 표현되지 않는 표현식 # 따라서 이진 트리로 만들 수 없다고 판별하여 0을 반환 if (num[parent_node]) == '0' and '1' in num: return 0 # 현재 이진트리를 반으로 쪼개서 왼쪽 트리를 스택에 넣기 stack.append(num[:parent_node]) # 오른쪽 트리를 스택에 넣기 stack.append(num[parent_node + 1:]) # 순회가 끝난 경우 완성할 수 있는 트리이므로 1을 반환 return 1 def solution(numbers): answer = [] # 현재 숫자들의 이진 값들이 담길 리스트 bin_nums = [] for num in numbers: # 현재 수를 이진수로 변환하기 bin_nums.append(conv_to_bintree(num)) for bin_num in bin_nums: # 변환된 수를 이진트리로 만들 수 있는지 확인하기 answer.append(verdict(bin_num)) return answer ‘이렇게하면 이렇게 되나…?’’ 하고, 손으로 그려가며 풀어본 문제였습니다. 복잡할 것 같은 문제도 코드로 적어내면 막상 길지 않은 경우가 있는데, 이 문제도 그런 경우였네요. 이번 문제는 이렇게 마무리하고 다음에는 제가 2023 KAKAO BLIND RECRUITMENT에서 풀면서 가장 재밌었던 표 병합의 해결 방법을 기록해보겠습니다. ","date":"2023-01-25","objectID":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/:2:2","tags":["python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표현 가능한 이진트리 (Python)","uri":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"categories":["Dev"],"content":"첫 번째 문제에 이어 다음으로 이모티콘 할인행사 문제 코드를 올려보려고 합니다. 프로그래머스의 2023 KAKAO BLIND RECRUITMENT 문제팩 필터를 통해 찾아볼 수 있으며, 🚀여기를 클릭하면 바로 이동할 수 있습니다. 제 코드는 가장 이상적인 해법이 아닙니다. 다만 저의 생각과 코드 작성의 방식을 공유하고자 글을 작성해봅니다.😋 ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/:0:0","tags":["python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 이모티콘 할인행사 (Python)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/"},{"categories":["Dev"],"content":"문제 🚀이모티콘 할인행사 참고 링크 | 프로그래머스의 문제를 외부에 게시할 수 있나요? ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/:1:0","tags":["python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 이모티콘 할인행사 (Python)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/"},{"categories":["Dev"],"content":"풀이 ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/:2:0","tags":["python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 이모티콘 할인행사 (Python)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/"},{"categories":["Dev"],"content":"1. 해결 아이디어 문제 해결 방법을 고민해보기 예전에는 코딩 테스트 문제를 풀 때 그리디 하게 문제 해결이 가능한가?를 먼저 생각했습니다. 그런데 그렇게 접근하는 것보다는 완전탐색이 가능한가?를 먼저 접근했을 때 더 빨리 문제 해결을 할 수 있었습니다. 탐색 시간을 생각해보고 안되겠다 싶으면 그리디한 문제 해결법을 찾는 순서로 문제를 해결하는 게 더 효율적일 때가 많더라고요. 엄격하게 속도를 파악했을 때, 순수 파이썬은 1초에 1000만 루프의 일을 처리할 수 있다고 합니다. 그러니까 대략 1000만번 미만의 시행 횟수의 경우 무난하게 통과할 수 있다고 예측할 수 있겠습니다. 참고 파이썬의 처리 속도에 대한 아티클: How Slow is Python Compared to C. (2020.07.13 작성) 시행횟수 짐작해보기 완전 탐색으로 문제를 해결한다고 할 경우 문제의 핵심이 되는 경우의 수는 이모티콘 할인의 가짓 수입니다. 문제에 의하면 이모티콘은 반드시 할인 가격으로 판매되는데 할인율의 경우 [10%, 20%, 30%, 40%]의 총 네 가지입니다. 그리고 고객들은 판매되는 가격 기준으로 이모티콘을 구매할지, 이모티콘 플러스를 구독할지 결정합니다. 고객의 수를 n으로, 이모티콘의 개수를 m이라고 할 경우 경우의 수는 4^m * n 입니다. 그런데 문제 제한 사항을 보면 이모티콘 개수는 최대 7개입니다. m의 값만 고려할 때, 4의 7 제곱의 경우 16,384번의 시행을 하게 되는 것이고 고객의 최대 수 값 100을 고려해도 1,638,400번의 시행횟수이므로 충분히 해볼만한 가짓수로 볼 수 있겠네요. 그래서 모든 이모티콘의 할인 경우의 수를 통해 문제를 해결해볼만 하다고 보고 모든 가짓수를 탐색하는 식으로 문제를 해결해보겠습니다. 모든 할인의 수를 어떻게 표현할 것인가? 모든 경우의 수를 찾는 것이므로 중복조합의 경우의 수를 고려하는 문제입니다. 여러 구현 방법이 있지만, 저는 재귀함수를 사용하는 편이 제일 편리하더라고요. 여기서는 먼저 재귀함수로 중복 조합을 표현하겠습니다. 그리고 파이썬에서는 itertools 모듈의 product가 자체적으로 중복조합을 제공합니다. 갓이썬… 그저 빛…⭐️ ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/:2:1","tags":["python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 이모티콘 할인행사 (Python)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/"},{"categories":["Dev"],"content":"2. 코드 1. 중복조합 코드 짜기 할인율은 10/20/30/40의 총 네 가지 값을 가집니다. 이모티콘이 하나일 경우 해당 할인율이 적용되는 네 가지의 경우가, 두 가지일 경우 4 * 4의 16가지 경우의 수가 만들어지겠죠. 두 이모티콘 모두 10% 할인으로 경우의 수를 늘려간다고 한다면 (10, 10), (10, 20), (10, 30), (10, 40), (20, 10), (20, 20) … (40, 20), (40, 30), (40, 40) 위와 같은 모든 할인 경우의 수를 살펴볼 것입니다. 재귀로 함수를 구현한다면 다음과 같은 코드가 될 것입니다. def 재귀함수(현재_인덱스 = 0, 현재_할인율_정보 = [0] * 이모티콘_개수): nonlocal 전체_할인률이_담기는_리스트 # 현재 인덱스를 0부터 이모티콘 개수까지 이동할텐데, 현재 인덱스가 이모티콘 개수와 같다면 모든 경우의 수를 변경해준 결과일 것입니다. if 현재_인덱스 == 이모티콘_개수: return 현재_할인율_정보 # 모든 할인율에 대해 # dc_rate는 [10, 20, 30, 40]을 넣은 값입니다. for 할인율 in dc_rate: 현재_할인율_정보[현재_인덱스] = 할인율 # 10, 20, 30, 40 중 하나를 넣어줍니다. # 다음 인덱스로 이동해줍니다. 재귀함수(현재_인덱스 + 1, 현재_할인율_정보) # 할인율 정보 리스트도 같이 넣어주죠. 중복 조합이기 때문에 그리 복잡하지 않은 재귀 함수가 완성됩니다. 해당 코드로 문제를 해결하는 코드를 완성하면 다음과 같습니다. solution() 함수 내부에 필요한 함수들을 넣었습니다. def solution(users, emoticons): # 문제에서 주어진 할인율 조건 네 가지 dc_rate = [10, 20, 30, 40] # 수많은 할인율의 경우의 수가 구현될 리스트의 초기 정보 temp_arr = [0] * len(emoticons) # 주어진 할인율에 따라 계산하는 함수 def cal(dc_info): # 구독자 수 sub_cnt = 0 # 구독하지 않을 경우 이모티콘에 지불한 금액 profit = 0 # 각 사용자에 대해 할인율 경우의 수를 적용해 연산해 봄 for user in users: # 사용자 정보는 (구매할 할인율 기준, 자산)으로 구성됨 dc_cut, budget = user # 이모티콘을 구매할 경우, 할인율이 적용된 이모티콘에 지불한 총액 sum_cost = 0 # 현재 사용자를 기준, 모든 이모티콘 금액을 순회 for idx, emo in enumerate(emoticons): # 현재 고객의 할인 등급율보다 현재 할인율이 더 높다면 # 즉 구매 대상인 이모티콘이라면 if dc_cut \u003c= dc_info[idx]: # 누적 지출에 현재 할인된 이모티콘 구매 가격을 더해준다. sum_cost += emo - int(emo * (dc_info[idx] / 100)) # 누적 지출 금액이 자산 이상이 된다면 # 즉 구매를 포기하고 구독을 원하게 된다면 if sum_cost \u003e= budget: # 구독자 수를 하나 더해준다. sub_cnt += 1 break # 만약 무사히 순회가 종료됐다면 # 구독하지 않고 이모티콘을 구매하는 것이므로 # 지금 고객의 지출 금액을 전체 수익에 더해준다. else: profit += sum_cost return [sub_cnt, profit] # 결과 = [구독자 수, 이모티콘 판매 이윤] result = [0, 0] # 이모티콘의 모든 할인율을 만드는 중복조합 만들기 def recur_sale(my_idx = 0, my_arr = temp_arr): nonlocal result # 현재 할인율이 완성되었다! if my_idx == len(emoticons): # 현재 할인율 정보(my_arr)로 이윤과 구독자 수를 구해보자! crnt_result = cal(my_arr) # 만약 현재 시행까지의 최대 구독자 수보다 지금 시행의 구독자 수가 더 많다면 if crnt_result[0] \u003e result[0]: # 지금 시행이 정답에 가깝다. result = crnt_result[:] # 구독자 수는 같은데, 이윤이 더 많다면 elif crnt_result[0] == result[0]: if crnt_result[1] \u003e result[1]: # 정답의 조건에 맞는다. result = crnt_result[:] return # 위의 코드와 마찬가지로 중복조합 만들어주기 for dc in dc_rate: my_arr[my_idx] = dc recur_sale(my_idx + 1, my_arr) # 실제 시행 recur_sale() return result 2. product 사용하기 파이썬의 product를 사용한다면 더 간편하게 문제를 해결할 수 있습니다. for 루프를 통해 product를 사용하는 방법은 다음과 같습니다. 수를 세는 경우의 값을 넣어주고, 해당 값이 총 몇 번 반복이 되는지는 repeat 옵션을 통해 넣어줍니다. 가령 [10, 20, 30, 40]의 가지 수가 모두 3가지 경우가 하나 씩 값을 가질 때 product([10, 20, 30, 40], repeat=3 으로 표현해줍니다. product 관련 코드는 51번째 줄부터입니다. from itertools import product def solution(users, emoticons): # 문제에서 주어진 할인율 조건 네 가지 dc_rate = [10, 20, 30, 40] # 수많은 할인율의 경우의 수가 구현될 리스트의 초기 정보 temp_arr = [0] * len(emoticons) # 주어진 할인율에 따라 계산하는 함수 def cal(dc_info): # 구독자 수 sub_cnt = 0 # 구독하지 않을 경우 이모티콘에 지불한 금액 profit = 0 # 각 사용자에 대해 할인율 경우의 수를 적용해 연산해 봄 for user in users: # 사용자 정보는 (구매할 할인율 기준, 자산)으로 구성됨 dc_cut, budget = user # 이모티콘을 구매할 경우, 할인율이 적용된 이모티콘에 지불한 총액 sum_cost = 0 # 현재 사용자를 기준, 모든 이모티콘 금액을 순회 for idx, emo in enumerate(emoticons): # 현재 고객의 할인 등급율보다 현재 할인율이 더 높다면 # 즉 구매 대상인 이모티콘이라면 if dc_cut \u003c= dc_info[idx]: # 누적 지출에 현재 할인된 이모티콘 구매 가격을 더해준다. sum_cost += emo - int(emo * (dc_info[idx] / 100)) # 누적 지출 금액이 자산 이상이 된다면 # 즉 구매를 포기하고 구독을 원하게 된다면 if sum_cost \u003e= budget: # 구독자 수를 하나 더해준다. sub_cnt += 1 break # 만약 무사히 순회가 종료됐다면 # 구독하지 않고 이모티콘을 구매하는 것이므로 # 지금 고객의 지출 금액을 전체 수익에 더해준다. else: profit += sum_cost return [sub_cnt, profit] # 결과 = [구독자 수, 이모티콘 판매 이윤] result = [0, 0] # 아래와 같이 간단히 중복조합을 사용할 수 있습니다. for info in product(dc_rate, repeat=len(emoticons)): cnrt_result = cal(info) sub_cnt, profit = cnrt_result # 아래부터는 result를 판별하는 코드입니다. if sub_cnt \u003e result[0]: result = cnrt_result elif sub_cnt == result[0]: if profit \u003e result[1]: result = cnrt_result return result ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/:2:2","tags":["python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 이모티콘 할인행사 (Python)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/"},{"categories":["Dev"],"content":"카카오의 2023년 블라인드 공개채용의 코딩테스트 문제가 공개되었습니다. 프로그래머스의 2023 KAKAO BLIND RECRUITMENT 문제팩 필터를 통해 찾아볼 수 있습니다. 🚀여기를 클릭하면 바로 이동할 수 있습니다. 공개된 문제 중 몇 가지 문제를 풀어 코드를 올려보려고 합니다. 제 코드는 가장 이상적인 해법이 아닙니다. 다만 저의 생각과 코드 작성의 방식을 공유하고자 글을 작성해봅니다.😋 ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/:0:0","tags":["JavaScript","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 개인정보 수집 유효기간 (JavaScript)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/"},{"categories":["Dev"],"content":"문제 🚀개인정보 수집 유효기간 참고 링크 | 프로그래머스의 문제를 외부에 게시할 수 있나요? ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/:1:0","tags":["JavaScript","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 개인정보 수집 유효기간 (JavaScript)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/"},{"categories":["Dev"],"content":"풀이 1번 문제로 자주 나오는 데이터 변환 문제입니다. 몇 가지 주의사항만 주의해주면 어려움 없이 해결할 수 있는 문제입니다. ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/:2:0","tags":["JavaScript","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 개인정보 수집 유효기간 (JavaScript)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/"},{"categories":["Dev"],"content":"1. 해결 아이디어 날짜 환산해주기 일자를 오늘 기준으로 유효한지 파악하는 문제입니다. 먼저 기준 일자 단위를 정합니다. 시간의 최소단위가 일자이므로 일 기준으로 각 날짜들을 환산해줍니다. 단 제한사항으로 가장 이른 시작 연도는 2000년이며, 각 월은 28일입니다. 따라서 연도는 2001년을 1, 2010년을 10 등의 단위 연도로 바꿔주기 위해 주어진 연도에 2000을 빼줍니다. 또한, 각 개월은 28일을 곱해서 일 수를 구해줍니다. 따라서 구하게 될 변환 날짜는 다음과 같습니다. 환산 일자 = ((기준 연도 - 2000) * 12개월 * 28일) + 개월 * 28 + 일 정책 정리하기 각 정책들은 개월 수로 표현됩니다. 또한 정책의 이름은 스트링인 알파벳으로 주어집니다. 따라서 정책 이름을 키 값으로, 유효 개월 수를 밸류로 하는 객체로 접근하면 데이터 접근이 편할 것 같네요. 기타 유의사항 정책 유효 기한은 만으로 1년입니다. 따라서 기준 일자의 일자에서 하나 부족한 날까지 유효합니다. 가령 유효 기간이 12개월이고 보관 시작일이 2021년 1월 5일이라면 2022년 1월 4일까지가 유효한 기간입니다. 이는 친절하게 문제해서도 알려주고 있네요. ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/:2:1","tags":["JavaScript","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 개인정보 수집 유효기간 (JavaScript)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/"},{"categories":["Dev"],"content":"2. 코드 따라서 코드를 작성하면 다음과 같습니다. // 연월일을 전달 받으면 이를 환산된 일자로 변환하는 함수 const convertDate = (date) =\u003e { const dateInfo = date.split(\".\").map(elm =\u003e Number(elm)); return (dateInfo[0] - 2000) * 12 * 28 + dateInfo[1] * 28 + dateInfo[2]; } const solution = (today, terms, privacies) =\u003e { const result = []; // 변환된 오늘 날짜 const _today = convertDate(today); // 정책 이름 - 개월 수를 key-value로 하는 객체 policyInfo = {}; terms.map(term =\u003e { const [policyName, month] = term.split(\" \"); /** month 값은 스트링이므로 Number로 변환해줍시다. * 여러 변환 방법이 있지만, * JavaScript 작성의 컨벤션으로 많이 사용되는 AirBnb의 숫자 변환은 Number()를 사용해주는 것입니다. * 여기서도 그렇게 해주도록 할게요. */ policyInfo[policyName] = Number(month) }) privacies.map((infos, idx) =\u003e { const [dateInfo, policy] = infos.split(\" \"); // 유효 완료 일자를 환산해준 값. 만으로 개월 수가 유효하기 때문에 1을 빼줍니다. const dateConverted = convertDate(dateInfo) + policyInfo[policy] * 28 - 1; // 만약 오늘이 유효 일자를 넘었다면 파기해야 할 정보이므로 결과에 넣어줍니다. if (_today \u003e dateConverted) { // 인덱스가 1부터 시작하니까 잊지 말고 1 더해주기. result.push(idx + 1); } }) return result; } ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/:2:2","tags":["JavaScript","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 개인정보 수집 유효기간 (JavaScript)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/"},{"categories":["Dev"],"content":"온라인 강의 사이트 udemy에서 React 완벽 가이드 with Redux, Next.js, TypeScript를 요즘 수강 중인데, 해당 강의에서 나온 내용을 기반으로 몇 가지 정리해보고자 합니다. 간단한 예시 화면을 만들어 보겠습니다. 멋진 팬톤의 Baby Blue를 배경색으로, Classic Blue를 버튼 색상으로 사용했습니다. 버튼이 있고 버튼을 누르면 텍스트 색상을 바꾸도록 해볼까요. 변했을 때 색상은 마찬가지로 팬톤 색상의 Rococco Red로 바꾸어 보겠습니다. ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:0:0","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"1. 인라인에서 직접 스타일 하기 (Inline Style) JSX 코드의 style을 직접 변경하는 경우입니다. isSwitched 라는 값을 Boolean 값으로 설정해서, 버튼을 눌렀을 때마다 false/true를 변환해주도록 했습니다. inline에서 스타일을 직접 지정할 경우 이중괄호를 사용합니다. 바깥 중괄호는 JSX 내 자바스크립트 코드를 사용하기 위한 중괄호이며, 내부 중괄호는 객체 리터럴을 사용하기 위한 중괄호입니다. 전체 코드는 다음과 같습니다. // src/components/StylePrac.js import React, { useState } from \"react\"; import \"./StylePrac.css\"; const StylePrac = () =\u003e { const [isSwitched, setIsSwitced] = useState(false); const switchHandler = () =\u003e { setIsSwitced(!isSwitched); }; return ( \u003cdiv\u003e \u003ch1 style={{ color: isSwitched ? \"#BB363F\" : \"#000\" }}\u003e Make our world colourful! \u003c/h1\u003e \u003cbutton className=\"StylePrac__button\" onClick={switchHandler}\u003eSwitch\u003c/button\u003e \u003c/div\u003e ); }; export default StylePrac; 여기서 관련된 코드 조각은 이 부분입니다. \u003ch1 style={{ color: isSwitched ? \"#BB363F\" : \"#000\" }}\u003e isSwitched가 true면 해당 문구를 로코코 레드에 해당하는 #BB363F 색으로, 그렇지 않으면 검은색으로 색칠됩니다. 만약 해당 문서의 기본 글꼴색이 검정색인 경우 다음과 같이 표현할 수도 있습니다. \u003ch1 style={{ color: isSwitched \u0026\u0026 \"#BB363F\" }}\u003e isSwitched 인 경우 로코코 레드 색상이 적용됩니다. ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:1:0","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"2. className을 동적으로 부여 인라인으로 스타일을 부여하는 경우 코드가 스타일에 집중되기 때문에 보기 힘듭니다. 클래스 속성을 동적으로 부여해 스타일을 관리하겠습니다. 이 경우는 템플릿 리터럴을 사용합니다. 클래스로 스타일을 관리할 것이니까, 먼저 해당 클래스 이름을 새롭게 만들면서 css를 작성해야겠죠. /* StylePrac.css */ /* 기본 색상인 검정색으로 지정합니다. */ .header-text { color: #000; } /* switched 클래스가 부여되면 아래 색상은 로코코 레드 색상이 적용됩니다. */ .switched { color: #BB363F; } JSX 코드는 다음과 같습니다. \u003ch1 className={`header-text ${isSwitched ? \"switched\" : \"\"}`}\u003e isSwitched가 true이면 해당 className은 “header-text switched\"가 되고, false면 “header-text\"만 남을 겁니다. 또한 다음과 같이 표현해도 같습니다. \u003ch1 className={`header-text ${isSwitched \u0026\u0026 \"switched\"}`}\u003e ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:2:0","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"3. CSS 모듈 사용 그냥 CSS를 사용하면 해당 클래스 네임의 스타일이 전역으로 적용되기 때문에 해당 컴포넌트에만 적용 가능한 스타일을 사용하는 것이 권장됩니다. CSS 클래스 컨벤션을 컴포넌트이름__클래스이름 과 같이 지정해줄 수도 있겠지만, 실수가 생길 수도 있죠. 따라서 해당 컴포넌트에 대응하는 스타일만을 적용하도록 해주는 여러가지 방법이 있습니다. 여기서는 CSS 모듈을 사용해보겠습니다. ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:3:0","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"1. module.css 파일 생성 CSS 파일을 CSS 모듈 파일로 만들어줍니다. 파일 확장자를 .css에서 .module.css로 바꾸어주기만 하면 됩니다. 다음과 같은 파일로 변경됩니다. 내용은 같습니다. 확장자면 바뀌네요. /* StylePrac.module.css */ .header-text { color: #000; } .switched { color: #BB363F; } ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:3:1","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"2. CSS module 불러오기 해당 컴포넌트의 자바스크립트 코드에서 해당 모듈을 불러옵니다. import React, { useState } from \"react\"; // 해당 불러오기 대신 // import \"./StylePrac.css\"; // CSS 모듈 파일을 불러와줍니다. import style from \"./StylePrac.module.css\" ... ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:3:2","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"3. style로 내부 속성 사용하기 style 을 불러왔기 때문에 먼저 style을 접근하고 내부에 있는 속성에 접근합니다. 각 스타일의 경우 JSX 내 자바스크립트 문법으로 표기해주어야 하므로 템플릿 리터럴을 사용합니다. 해당 표기에서는 다른 객체에 접근하는 것처럼 점 표기법(Dot Notation)과 대괄호 표기법(Bracket Notation) 모두 사용할 수 있습니다. 단, 스타일에서 사용하는 클래스 이름의 경우 케밥 케이스를 사용하는 경우가 많기 때문에, 상황에 맞게 대괄호 표기법을 사용해줍니다. 해당 JSX 코드 조각을 다음과 같습니다. // StylePrac.js ... \u003ch1 className={`${style[\"header-text\"]}${isSwitched \u0026\u0026 style[\"switched\"]}`}\u003e // style.switched와 같이 점 표기법으로 아래와 같이 표시하는 것도 동일합니다. // \u003ch1 className={`${style[\"header-text\"]} ${isSwitched \u0026\u0026 style.switched}`}\u003e 개발자 도구를 통해 해당 HTML을 확인해보면 해당 컴포넌트(여기서는 StylePrac.js)의 고유한 클래스 값이 적용된 것을 확인할 수 있습니다. 색상 네모 내부의 고유 값이 지정되었음을 확인할 수 있습니다. 해당 컴포넌트의 전체 코드는 다음과 같습니다. import React, { useState } from \"react\"; import style from \"./StylePrac.module.css\" const StylePrac = () =\u003e { const [isSwitched, setIsSwitced] = useState(false); const switchHandler = () =\u003e { setIsSwitced(!isSwitched); }; return ( \u003cdiv\u003e \u003ch1 className={`${style[\"header-text\"]}${isSwitched \u0026\u0026 style[\"switched\"]}`}\u003e Make our world colourful! \u003c/h1\u003e \u003cbutton className={style[\"StylePrac__button\"]} onClick={switchHandler}\u003eSwitch\u003c/button\u003e \u003c/div\u003e ); }; export default StylePrac; ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:3:3","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev","Data Structure"],"content":" 입력 상자에 입력된 어절을 기반으로, 이전에 입력한 키워드를 자동으로 완성하는 방법을 알아봅니다. 자료구조 Trie을 통해 구현할 수 있죠. 제가 정말 잘 샀다 싶은 앱들이 몇 있는데요, 편한가계부 는 그 중 하나입니다. (iOS에서는) 문자를 기반으로 사용자의 결제 내역을 자동으로 저장해주고, 일정 기간별로 통계를 보여주어 지난 한 기간에서의 지출 내용을 통한 미래 지출 계획 설계, 자가 분석 (+ 반성) 등을 도와주는 앱입니다. 그리고 각 결제 내역을 입력할 때 세부 내용을 입력할 수 있는데, 단어 조각을 입력하면 사용자가 과거에 입력했던 기록을 기반으로 입력할 내용을 찾아줍니다. 이렇게요. 특히 내가 입력했던 내용 을 찾아 보여주기 때문에, 구구절절하게 기입했던 내용 역시 잘 기억해놨다가 알아서 입력해줍니다. 저는 내용을 자세하게 적는 편인데, 예를 들어 서브웨이 터키 6인치 위트 피클류 제외 음료 없이 이라고 적거든요. 그리고 서브웨이에 가면 보통 먹었던 메뉴를 먹고요. 그 때마다 저 20음절의 어구를 직접 입력하는 것이 아니라, 서브라는 2음절만 완성해도 해당 내용을 알아서 찾아 주기 때문에 정말 편리합니다. 이와 같이 사용자가 입력했던 내용을 기반으로 자동완성해주는 기능을 구현해보도록 하겠습니다. 여러가지 방법이 있겠지만 여기서는 Trie 자료구조를 활용해보려고 합니다. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:0:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"Trie. 단어를 빠르게 찾는 자료구조 트라이 인덱싱(trie indexing) 정보·통신 가변 크기의 키 값을 다룰 때 특히 유용한 인덱스 구조. 트라이는 키 값 전체가 아니라 그 일부에 의해 각 레벨의 분기가 결정되는 차수 m≥2인 트리를 의미하며, 분기 노드와 정보 노드라는 두 종류의 노드를 갖는다. ⇒규범 표기는 미확정이다. 출처: 우리말샘 | 네이버 국어사전 사전에는 어렵게 설명 되어있네요… Trie는 Tree 구조와 유사한 형태를 가지는 자료구조입니다. 우리말 규범 표기는 미확정이지만, 영미 문화권에서는 Tree구조와 구분하기 위해 [트라이]로 읽는 것이 일반적입니다. 이 글에서는 단어를 색인하는 목적의 Trie 자료구조에 한정해서 이야기 해봅시다. Trie는 트리 구조와 유사한 형태로, 각 노드는 로마자에서는 하나의 알파벳 기준으로 만들어지며, 하나의 노드는 다음의 노드의 키가 되는 형태로 이루어진 자료구조입니다. 구문으로 풀어 쓰면 어려워 보이지만, 그림으로 보면 더 쉽게 이해할 수 있습니다. Wikipedia. “Trie”. https://en.wikipedia.org/wiki/Trie 상단의 그림을 봐볼까요? Wikipedia의 Trie 항목에서 가져온 그림입니다. Trie는 일종의 사전입니다. 위의 Trie는 A, to, tea, ted, ten, inn의 총 6개 단어가 저장된 Trie입니다. 트리구조처럼 부모 노드가 자식 노드를 갖는 형태를 가지며, 각 단어의 바로 앞선 글자가 부모가 되며 그 다음 글자가 자식이 됩니다. 또한 맨 처음 노드인 head 는 비어있습니다. 상단 그림에서 3번으로 표기된 tea 를 기준으로 해당 자료구조를 설명해보겠습니다. 안내 다음의 Trie 구현은 하나의 예시일 뿐이며, 상황에 따라 다르게 사용됩니다. 본 코드에서는 Node에서 word라는 값을 사용했지만, 코드에 따라 boolean을 통해 해당 단어가 마지막인지 체크만하는 코드도 존재합니다. 각 글자(로마자의 경우 알파벳)의 경우 Node로 구성되어 있으며, 각 노드는 key, word, children으로 구성되어 있습니다. 구조를 설명하면서 완성된 단어라는 표현을 사용할 건데요, 이는 tea, ted, inn처럼 Trie에 입력되는 하나의 단어를 지칭하는 표현으로 사용하도록 하겠습니다. 먼저, 1. 최상단 부모노드 head 는 비어있습니다. 각 단어의 첫 글자는 head의 자식이 됩니다. 따라서, tea 의 첫 글자 t 는 head 의 자식이 됩니다. 노드를 기준으로 설명하면, head 노드의 key는 비어있는 노드이므로 언어에 따라 null 혹은 None 이 되고, children에는 노드 t 가 담기게 됩니다. 이 부분은 글로는 어렵지만, 아래 코드를 통해 본다면 훨씬 수월히 이해가 될 것입니다. 2. 바로 다음 글자는 앞선 글자의 자식이 됩니다. tea 의 첫 글자 t는 head의 자식인 노드가 되며 key 값으로 t라는 값을 가지게 됩니다. 두 번째 글자 e 는 첫 번째 글자인 t 의 자식이 됩니다. 또한 연쇄적으로 두 번째 글자 e는 세 번째 글자 a 의 부모가 됩니다. 노드 기준으로는 t 값을 key로 가지는 노드의 children 에 e 노드가 담기게 되고, 다시 e 를 key 로 가지는 노드는 a 노드를 children 에 담습니다. 추가적으로, 여기서 만들어진 Trie는 to 라는 단어를 가지고 있기 때문에, 그림의 7번을 보면 t는 또 다른 자식인 o를 갖는 것을 볼 수 있습니다. 3. 단어의 마지막 글자는 해당 글자가 완성되었다는 정보를 갖습니다. 완성된 단어의 마지막 글자는 해당 글자가 완성되었다는 정보를 가집니다. 노드의 관점에서 보면, 해당 노드의 word에 완성된 단어의 값을 넣습니다. 완성된 단어가 아닌 경우 각 노드의 word는 none 혹은 null 값을 가질 것이며, 해당 노드가 완성된 단어의 마지막 글자일 경우 word값으로 완성된 단어를 가질 것입니다. 여기서는 a노드의 word값에 tea라는 값이 담기게 됩니다. 노드의 word 값을 통해 해당 단어가 완성된 단어인지 즉, Trie에 이 단어가 입력이 되어있는지 판별하게 됩니다. 위의 그림을 기준으로 한다면 각 노드를 표현한 동그라미 안에 쓰여진 to, te, tea, ted 와 같은 값들이 이에 해당합니다. 다만 실제 코드에서는 완성된 단어가 아닐 경우 null 값을 넣어주고, 완성된 단어일 경우에만 해당 단어를 넣어줄 것입니다. 이 설명 역시 글로는 어렵지만, 코드를 본다면 명확히 이해가 될 것입니다. 만약 글로 해당 구조가 그려지는 분들 중 이런 의문을 가지는 분들이 있을 수 있겠습니다. “그냥 자식이 없는 노드를 기준으로 완성된 단어인지 판별하면 되는 거 아닌가?” 하지만 자식을 가지지 않는 노드가 해당 단어의 마지막 글자다라는 기준으로만 해당 글자가 완성된 단어의 마지막 글자인지 판별하게 된다면 다음과 같은 상황에서 놓치게 되는 단어들이 있을 수 있습니다. 가령 Trie에 tea 라는 단어와 tealeaf 라는 단어가 모두 포함 되어 있을 경우죠. 이 경우 a 노드는 word 에 완성된 단어인 tea 라는 가짐과 동시에 자식으로 l을 가지게 됩니다. 즉, 자식을 가지고 있는 노드지만 tea라는 완성된 단어의 마지막 노드가 되는 것이지요. 따라서 해당 노드가 자식을 가지지 않는다를 기준으로 해당 단어가 완성된 단어인가를 판별하는 것은 위험합니다. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:1:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"자 이제 코드로 봅시다! 역시 코드로 보는 게 빠르지요. 먼저 Javascript로 보도록 하겠습니다. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"1. class로 구현 // 각 단어의 글자가 담길 Node class Node { constructor(key, word = null) { // key는 각 단어의 알파벳 this.key = key; // word는 해당 key가 단어의 마지막 글자일 경우 해당 단어를 담아줍니다. // 따라서 처음 값은 null this.word = word; // children의 Object에는 자식이 되는 글자를 key로, value에는 Node를 담아줍니다. this.children = {}; } } class Trie { constructor() { // 처음 생성되는 노드인 헤드는 key 값이 비어있는 노드입니다. this.head = new Node(null); } // insert는 해당 Trie에 단어를 담는 메소드입니다. // Trie.insert(\"tea\");와 같은 형태로 Trie에 단어를 담아줍니다. insert(string) { // 위에서 보았던 그림과 같이 순차적으로 노드를 탐색합니다. // 첫 노드는 head가 됩니다. // string이 'tea'일 경우, 첫 노드는 head, 그 다음 노드는 t, 그 다음은 e이며 마지막 노드는 a일 것입니다. let currNode = this.head; // string(단어)의 각 글자를 하나하나 탐색하며 Node에 담아줍니다. for (const char of string) { // 해당 글자가 children에 처음 담기는 글자일 경우 새로운 노드를 만들어 넣어줍니다. /* * 가령 이 Trie에 'to'를 insert하고 'tea'를 insert 했다면 * 'to'의 't'는 처음 입력되는 값이므로 아래 if문에 걸려 new Node가 작동할 것이지만 * 두 번째 입력된 'tea'의 't'는 head의 자식으로 이미 존재하기 때문에 아래 가정문에 걸리지 않을 것입니다. */ if (!(char in currNode.children)) { // 현재 노드에 처음으로 생성된 자식이라면 char를 key로 하는 새로운 노드를 만들어 Object에 넣습니다. currNode.children[char] = new Node(char); } // 자식 노드를 현재 노드로 바꾸어 주고 다음 for-loop를 시행합니다. currNode = currNode.children[char]; } // for-loop가 종료되었다면, 즉 해당 currNode(현재 노드)가 마지막 글자가 되었다면, word값을 null이 아닌 string(완성된 단어)을 입력해줍니다. // 'tea'라는 단어를 insert 했다면 'a' 노드만 word 값으로 'tea'를 가지고, 't'와 'a'의 word는 null일 것입니다. currNode.word = string; } // Trie에 string이라는 값이 있는지 탐색하는 메소드입니다. search(string) { // 첫 시작노드는 head가 됩니다. let currNode = this.head; // 찾고자 하는 단어의 각 글자(로마자의 경우 알파벳)을 기준으로 하나하나 탐색합니다. for (const char of string) { // 현재 노드의 자식으로 다음 글자가 존재한다면 if (char in currNode.children) { // 다음 노드는 현재 노드로 바꾸어 줍니다. currNode = currNode.children[char]; // 다음 글자가 현재 노드의 자식으로 존재하지 않는다면 } else { // 찾고자 하는 단어가 없는 것이므로 false를 반환합니다. return false; } } // for-loop가 무사히 종료되어 마지막 노드가 현재 노드(currNode)가 됐을 경우 // 현재 노드의 word가 찾고자 하는 단어와 같다면 if (currNode.word === string) { // 해당 단어는 본 Trie에 포함되어있다는 의미의 true를 반환합니다. return true; // 그렇지 않은 경우는 해당 단어가 Trie에 없는 경우이므로 false를 반환합니다. /* * 예를 들어 Trie에 'tealeaf'라는 단어가 포함되어있지만 'tea'라는 단어가 포함되어있지 않은 경우라면 * 'tea'라는 단어를 해당 Trie에서 찾을 경우, for-loop는 무사히 수행하지만 * 해당 Trie에는 존재하지 않는 단어입니다. */ } else { // 따라서 해당 단어는 본 Trie에 포함되어있지 않으므로 false를 반환합니다. return false; } } } ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:1","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"2. function으로 구현 // 각 주석은 위의 class 코드에 적힌 주석과 똑같습니다. // 각 단어의 글자가 담길 Node const Node = function(key, word = null) { // key는 각 단어의 알파벳 this.key = key; // word는 해당 key가 단어의 마지막 글자일 경우 해당 단어를 담아줍니다. // 따라서 처음 값은 null this.word = word; // children의 Object에는 자식이 되는 글자를 key로, value에는 Node를 담아줍니다. this.children = {}; } const Trie = function() { // 처음 생성되는 노드인 헤드는 key 값이 비어있는 노드입니다. this.head = new Node(null); // insert는 해당 Trie에 단어를 담는 메소드입니다. // Trie.insert(\"tea\");와 같은 형태로 Trie에 단어를 담아줍니다. this.insert = function(string) { // 위에서 보았던 그림과 같이 순차적으로 노드를 탐색합니다. // 첫 노드는 head가 됩니다. // string이 'tea'일 경우, 첫 노드는 head, 그 다음 노드는 t, 그 다음은 e이며 마지막 노드는 a일 것입니다. let currNode = this.head; // string(단어)의 각 글자를 하나하나 탐색하며 Node에 담아줍니다. for (const char of string) { // 해당 글자가 children에 처음 담기는 글자일 경우 새로운 노드를 만들어 넣어줍니다. /* * 가령 이 Trie에 'to'를 insert하고 'tea'를 insert 했다면 * 'to'의 't'는 처음 입력되는 값이므로 아래 if문에 걸려 new Node가 작동할 것이지만 * 두 번째 입력된 'tea'의 't'는 head의 자식으로 이미 존재하기 때문에 아래 가정문에 걸리지 않을 것입니다. */ if (!(char in currNode.children)) { // 현재 노드에 처음으로 생성된 자식이라면 char를 key로 하는 새로운 노드를 만들어 Object에 넣습니다. currNode.children[char] = new Node(char); } // 자식 노드를 현재 노드로 바꾸어 주고 다음 for-loop를 시행합니다. currNode = currNode.children[char]; } // for-loop가 종료되었다면, 즉 해당 currNode(현재 노드)가 마지막 글자가 되었다면, word값을 null이 아닌 string(완성된 단어)을 입력해줍니다. // 'tea'라는 단어를 insert 했다면 'a' 노드만 word 값으로 'tea'를 가지고, 't'와 'a'의 word는 null일 것입니다. currNode.word = string; } // Trie에 string이라는 값이 있는지 탐색하는 메소드입니다. this.search = function(string) { // 첫 시작노드는 head가 됩니다. let currNode = this.head; // 찾고자 하는 단어의 각 글자(로마자의 경우 알파벳)을 기준으로 하나하나 탐색합니다. for (const char of string) { // 현재 노드의 자식으로 다음 글자가 존재한다면 if (char in currNode.children) { // 다음 노드는 현재 노드로 바꾸어 줍니다. currNode = currNode.children[char]; // 다음 글자가 현재 노드의 자식으로 존재하지 않는다면 } else { // 찾고자 하는 단어가 없는 것이므로 false를 반환합니다. return false; } } // for-loop가 무사히 종료되어 마지막 노드가 현재 노드(currNode)가 됐을 경우 // 현재 노드의 word가 찾고자 하는 단어와 같다면 if (currNode.word === string) { // 해당 단어는 본 Trie에 포함되어있다는 의미의 true를 반환합니다. return true; // 그렇지 않은 경우는 해당 단어가 Trie에 없는 경우이므로 false를 반환합니다. /* * 예를 들어 Trie에 'tealeaf'라는 단어가 포함되어있지만 'tea'라는 단어가 포함되어있지 않은 경우라면 * 'tea'라는 단어를 해당 Trie에서 찾을 경우, for-loop는 무사히 수행하지만 * 해당 Trie에는 존재하지 않는 단어입니다. */ } else { // 따라서 해당 단어는 본 Trie에 포함되어있지 않으므로 false를 반환합니다. return false; } } } 기본적인 코드는 이렇게 됩니다. 사용은 어떻게 하면 되는지 아래에서 보여드릴게요. 코드에 대한 내용은 주석을 참고해주세요. 위 코드는 주석이 많으니까 복붙해서 쓰시려는 분들은 아래 코드를 사용해주세요. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:2","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"3. 기본적인 사용 예시 const Node = function(key, word = null) { this.key = key; this.word = word; this.children = {}; } const Trie = function() { this.head = new Node(null); this.insert = function(string) { let currNode = this.head; for (const char of string) { if (!(char in currNode.children)) { currNode.children[char] = new Node(char); } currNode = currNode.children[char]; } currNode.word = string; } this.search = function(string) { let currNode = this.head; for (const char of string) { if (char in currNode.children) { currNode = currNode.children[char]; } else { return false; } } if (currNode.word === string) { return true; } else { return false; } } } // 간단한 사용 예시 코드 // new 키워드를 사용해 생성자 함수 만들기 const trie = new Trie(); // 이 단어들을 Trie에 넣어주도록 해볼게요. const stringArr = [\"apple\", \"apollo\", \"apptite\", \"appstore\", \"appdulla\"]; stringArr.forEach(string =\u003e { // 만들어진 trie에 insert 메소드를 통해 단어들을 넣습니다. trie.insert(string); }) // apple이라는 값이 이 trie에 있니? console.log(\"apple: \", trie.search(\"apple\")); // true // apollo는? console.log(\"apollo: \", trie.search(\"apollo\")); // true // 혹시 apgujeong도? console.log(\"apgujeong: \", trie.search(\"apgujeong\")); // false 이렇게 사용하면 됩니다. 역시 결과값으로 보니까 훨씬 낫네요. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:3","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"Trie를 활용해 자동완성 입력창 만들기 이제 Trie를 어느정도 쓸 수 있을 것 같으니까 실제 기능구현으로 활용해봅시다. 사용자가 입력한 값을 저장하고, 이 값을 자동완성해주는 기능을 구현해보겠습니다. 다음과 같은 입력상자가 있고 아래에 자동 완성이 되도록 만들어보겠습니다. 고맙게도 입력한 값을 기준으로 잘 나타나고 있네요. 참고로 로마자는 알파벳 기준으로 하나의 노드가 완성되지만, 한글의 경우는 완성된 하나의 음절 혹은 따로 떨어져 입력된 자소 단위로 노드가 완성됩니다. 따라서 o(이응)과 아는 전혀 상관없는 별개의 노드가 되고, o(이응)은 아의 부모노드가 되지 않습니다. 기존의 코드와는 다르게, 단어가 완성되지 않았을 때 완성될 것으로 예상되는 단어들을 보여주어야 합니다. 따라서 search() 메소드를 조금 수정했습니다. 코드는 다음과 같습니다. \u003c!-- index.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003c/head\u003e \u003cbody\u003e \u003cmain class=\"App\"\u003e \u003c/main\u003e \u003cscript src=\"trie.js\" \u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e // trie.js const $app = document.querySelector(\".App\"); const $inputBox = document.createElement(\"input\"); $app.appendChild($inputBox); const $textBox = document.createElement(\"p\"); $app.appendChild($textBox); const Node = function(key, word = null) { this.key = key; this.word = word; this.children = {}; } const Trie = function() { this.head = new Node(null); this.insert = function(string) { let currNode = this.head; for (const char of string) { if (!(char in currNode.children)) { currNode.children[char] = new Node(char); } currNode = currNode.children[char]; } currNode.word = string; } this.search = function(string) { let currNode = this.head; for (const char of string) { if (char in currNode.children) { currNode = currNode.children[char]; } else { return; } } // 현재 입력한 값을 기준으로 만들 수 있는 단어들을 넣어줍니다. let foundWords = []; // 재귀함수를 통해 현재 단어를 기준으로 만들 수 있는 단어들을 찾습니다. const recurSearch = (currNode) =\u003e { // 현재 노드에 완성된 단어가 있고 if (currNode.word) { // 찾은 단어가 아직 배열에 들어있지 않다면, 해당 단어를 삽입해줍니다. if (!(currNode.word in foundWords)) { foundWords = [ ...foundWords, currNode.word ]; } } // 현재 노드 기준으로 자식 단어를 찾습니다. for (const child in currNode.children) { recurSearch(currNode.children[child]); } } recurSearch(currNode); return foundWords; } } const trie = new Trie(); // 출력된 내용을 보여주는 코드 $inputBox.addEventListener(\"keyup\", e =\u003e { $textBox.innerHTML = null; if (e.target.value) { const results = trie.search(e.target.value); if (results) { $textBox.innerHTML = results.map(result =\u003e `\u003cp class=\"result\"\u003e${result}\u003c/p\u003e`).join(\"\") } } if (e.key === \"Enter\" \u0026\u0026 e.target.value) { trie.insert(e.target.value); $inputBox.value = null; } }) ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:3:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"Debouncing을 활용, 입력완료까지 기다렸다가 자동완성하기 입력과 동시에 자동완성을 하는 것이 아니라, 사용자의 입력이 완료되었다고 판단한 후에 자동완성을 보여주는 것이 더 보기 좋을 것 같은데 한 번 해볼까요? Debouncing을 통해 구현할 수 있습니다! 아까와는 다르게 문구가 입력된 후 일정 시간이 지났을 때만 자동완성이 노출되도록 했습니다. 오 뭔가 조금 더 깔끔해진 기분이 듭니다. Debouncing에 관한 자세한 설명은 해당 링크를 참조해주세요. Debouncing을 적용한 코드는 다음과 같습니다. const $app = document.querySelector(\".App\"); const $inputBox = document.createElement(\"input\"); $app.appendChild($inputBox); const $textBox = document.createElement(\"p\"); $app.appendChild($textBox); // Debouncing을 합니다! const debounce = (func, delay) =\u003e { let debounceTimer; return function() { const context = this; const args = arguments; clearTimeout(debounceTimer); debounceTimer = setTimeout(() =\u003e func.apply(context, args), delay); } } const Node = function(key, word = null) { this.key = key; this.word = word; this.children = {}; } const Trie = function() { this.head = new Node(null); this.insert = function(string) { let currNode = this.head; for (const char of string) { if (!(char in currNode.children)) { currNode.children[char] = new Node(char); } currNode = currNode.children[char]; } currNode.word = string; } this.search = function(string) { let currNode = this.head; for (const char of string) { if (char in currNode.children) { currNode = currNode.children[char]; } else { return; } } let foundWords = []; const recurSearch = (currNode) =\u003e { if (currNode.word) { if (!(currNode.word in foundWords)) { foundWords = [ ...foundWords, currNode.word ]; } } for (const child in currNode.children) { recurSearch(currNode.children[child]); } } recurSearch(currNode); return foundWords; } } const trie = new Trie(); $inputBox.addEventListener(\"keyup\", e =\u003e { $textBox.innerHTML = null; if (e.key === \"Enter\" \u0026\u0026 e.target.value) { trie.insert(e.target.value); $inputBox.value = null; } }) // Debouncing을 적용합니다! // 350ms를 기준으로 입력했습니다. $inputBox.addEventListener(\"keyup\", debounce(e =\u003e { if (e.target.value) { const results = trie.search(e.target.value); if (results) { $textBox.innerHTML = results.map(result =\u003e `\u003cp class=\"result\"\u003e${result}\u003c/p\u003e`).join(\"\") } } }, 350)) 지연을 주고 출력하고 싶다면, 다음과 같이 디바운싱을 활용할 수 있습니다. 지연시간을 조절하면서 목적에 맞도록 구현하면 좋을 것 같네요.😄 ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:3:1","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"마치며 해당 포스트를 작성하며 찾아보았는데, 자동완성을 구현하는 방법은 많습니다. 특정 라이브러리나 브라우저의 자동완성 기능을 활용할 수도 있고요. 본 포스트에서는 Trie 자료구조에 대해 알아보고, 이를 활용할 수 있는 하나의 예시로 자동완성에 적용해보았습니다. Trie 자료구조의 시간복잡도는 문자열 길이 m에 대해 O(m) 입니다. 다만 문자열이 공간을 많이 차지하여, 공간 복잡도는 매우 크게 나타날 수 있습니다. Trie 구조 역시 상황에 따라 필요하다고 생각될 때 올바르게 사용하는 것이 중요할 것 같습니다.🤔 ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:4:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev"],"content":" 사용자의 입력을 기다렸다가 완전히 입력이 종료되었다고 판단되면 입력을 받도록 합니다. 디바운싱을 활용해서요. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:0:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"디바운싱이란? 사용자의 입력을 받아 처리해야 합니다. 단, 사용자의 모든 입력이 종료되었을 때만 입력을 받고 엔터 키를 누르는 등 입력이 종료되었다는 별도의 액션이 없습니다. 사용자의 입력이 완료 되었음을 어떻게 알고 처리할 수 있을까요? 간단해보이지만 실제로 구현하고자 하면 생각보다 쉽지 않을 것입니다. 이러한 문제를 해결하기 위한 개념이 deboucing 입니다. 디바운싱(debouncing) 기계식 스위치의 동작을 전기적 신호로 바꿀 때 생기는 진동 잡음을 제거하기 위하여 사용하는 하드웨어의 지연 회로, 소프트웨어의 적절한 지연 시간. 출처 : 컴퓨터 인터넷 IT용어 대사전 | 네이버 사전 사전에서는 목적에 맞는 처리를 위한 소프트웨어의 적절한 지연 시간을 디바운싱이라고 정의하고 있습니다. 디바운싱이 필요한 경우는 어떤 경우이며, 또 어떻게 적용해야 할까요? 제가 디바운싱을 통해 문제를 해결했었던 경험을 통해 디바운싱에 대해 이야기 해볼까 합니다. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:1:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"문제상황. ‘RFID 코드 입력을 처리해야하는데…’ 화면에서 RFID 번호를 입력을 받아야 했습니다. RFID란 간단히 말하자면 식별이 가능한 태그입니다. 바코드와 비슷한데, 교통카드처럼 접촉으로 인식하며 상품의 종류 뿐 아니라 각 상품 하나를 인식하며 관리하기 위해 쓰이는 게 보통입니다. 가령 바코드는 \"삑! 이건 사과, 삑! 이건 바나나\"로 인식한다면, RFID는 \"삑! 이건 어제 네 번째로 들어온 청송사과, 삑! 이건 어제 첫 번째로 들어온 충주사과\" 이런 식이죠. 바코드와는 다르게 각 상품에 1:1로 매칭이 되는 것이지요. 요런 식으로 제품에 붙어있답니다.여기 붙어있는 RFID 값은 저희 집 찬장 구석에 내용물은 모두 내어주고 병만 남은 이 잭다니엘에게만 주어진 고유한 값이죠 자, 그래서 프로젝트 진행 중 RFID 코드를 입력받아야 했습니다. RFID 리더기를 사용해 RFID 태그의 입력을 받았죠. RFID 리더기나 바코드 인식기 등, 입력을 받는 기기들은 보통 입력 값을 입력해주고 자동으로 엔터를 자동으로 입력해 처리해줍니다. 그러나 RFID 리더기를 통해서 상품을 읽히는데 예상과는 다르게 입력이 되었습니다. 기대했던 작동 방식 (희망편): RFID 태그를 리더기에 인식 -\u003e RFID 번호 값이 입력된 후 자동으로 엔터 입력 -\u003e 원하는 로직 처리 -\u003e RFID 리더기에 새로운 태그 인식 (반복) 실제 작동한 방식 (절망편): RFID 태그를 리더기에 인식 -\u003e 바로 엔터가 입력되지 않고 근처에 있는 RFID 코드 값이나 방금 인식된 값이 또 입력 -\u003e 엔터 입력 -\u003e 로직 처리 중, 그러나 그 와중에도 입력되고 있는 RFID 번호 -\u003e (서비스) ‘아 잠깐만여 이 번호는 또 뭐여’ -\u003e 그 와중에도 입력되고 있는 RFID -\u003e 으어어 (반복) 이런 상황이 발생하고 있었고 실제로 입력된 값들은 다음과 같았습니다. 기대했던 입력값: AAA00000000001 (엔터) -\u003e AAA00000000002 (엔터) -\u003e A000000000003 (엔터) 실제 입력값: AAA00000000001AAA00000000002A00000000 (엔터) 두 개의 온전한 RFID 번호와 불온전한 번호 하나가 결합한 형태 문제를 요약하자면, 하나의 입력 값을 받고 바로 엔터처리가 되지 않음 다른 RFID 태그가 근처에 있으면 같이 입력됨 혹은, 방금 태그한 RFID 태그가 다시 입력 됨 엔터가 입력되고 로직이 처리되는 과정에서 RFID 값이 또 입력 돼, 끝까지 인식되지 않은 RFID 입력 값이 발생 다음의 네 가지와 같았습니다. 따라서 입력이 완료 되었다고 판단 되었을 때 로직을 실행할 것, 입력된 RFID 중 중복 값을 제거하고 올바른 RFID만 모아 처리할 것 의 두 가지 해결 목표가 생겼습니다. ‘흠, 그렇다면 먼저 첫 번째 목표인 입력이 완료되었을 때... 를 어떻게 판별하고 처리해야할까…‘의 고민 중 문제해결 방법을 찾았고 디바운싱을 적용한다면 이 문제를 해결할 수 있다는 것을 알게 되었습니다. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:2:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"디바운싱. Javascript로 구현하기 Javascript 코드를 통해 디바운싱을 구현해봅시다. 사실 자바스크립트의 라이브러리 lodash 에서 debounce 메소드를 통해 손쉽게 디바운싱을 사용할 수 있습니다. 코드 원소스: https://www.geeksforgeeks.org/lodash-_-debounce-method/ // 출처: GeeksforGeeks // Requiring lodash library const _ = require('lodash'); // Using _.debounce() method // with its parameters var debounce_fun = _.debounce(function () { console.log('Function debounced after 1000ms!'); }, 1000); debounce_fun(); 여기서는 lodash의 도움을 구하지 않고 직접 코드를 써서 사용해볼까요. 코드 원소스: https://www.geeksforgeeks.org/debouncing-in-javascript/?ref=gcse // 출처: GeeksforGeeks const debounce = (func, delay) =\u003e { let debounceTimer return function() { const context = this const args = arguments clearTimeout(debounceTimer) debounceTimer = setTimeout(() =\u003e func.apply(context, args), delay) } } clearTimeout() 메소드는 이전에 생성되어 사용된 setTimeout() 을 취소하는 메소드입니다. 디바운싱 함수는 클로저를 이용한 형태로 만들어져있습니다. 따라서 함수 debounce의 실행 컨텍스트가 종료된 뒤에도 선언된 변수 debouncerTimer 는 사라지지 않고, setTimeout의 delay 시간이 남아있는 상태에서 또 다시 setTimeout의 delay 시간만큼 실행하고자 하는 함수 func를 기다리는 대상이 됩니다. 해당 내용은 기회가 된다면 따로 다루는 것이 좋겠네요. 간단하게 디바운싱이 작동하는 페이지를 만들어 봅시다. input 상자가 있고, 상자에 입력하는 문구가 하단에 기입이 되게 할 것입니다. 텍스트의 입력을 기다리고, 입력이 완료됐다고 판단되면 텍스트가 출력되는 디바운싱을 구현해봅니다. 실제는 이렇게 작동합니다. 입력이 완료될 때까지 잘 기다리고 있다가 작동하네요. 상황에 따라서 실시간으로 입력을 받거나, 디바운싱을 받거나 선택해서 사용하면 되겠지요. 코드는 다음과 같습니다. \u003c!-- index.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003c/head\u003e \u003cbody\u003e \u003cmain class=\"App\"\u003e \u003c/main\u003e \u003cscript src=\"debounce.js\" \u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e // debounce.js const $app = document.querySelector(\".App\") const $inputBox = document.createElement(\"input\") $app.appendChild($inputBox) const $textBox = document.createElement(\"p\") $app.appendChild($textBox) // 실제 Debouncing 관련 코드 const debounce = (func, delay) =\u003e { let debounceTimer return function() { const context = this const args = arguments clearTimeout(debounceTimer) debounceTimer = setTimeout(() =\u003e func.apply(context, args), delay) } } // 500ms의 지연시간을 준 debouncing $inputBox.addEventListener(\"keydown\", debounce(e =\u003e { $textBox.innerHTML = e.target.value }, 500)) 입력 지연시간은 실제로 서비스에 적용하면서 가장 적절한 값을 찾는 게 좋겠네요. 200, 300ms 혹은 여유있게 1초(1000ms)를 지연하는 것도 상황에 따라 괜찮을 것 같습니다. 다음과 같은 디바운싱으로 RFID 리더기의 입력 값을 기다리고 모든 인식이 끝났을 때 문자열을 입력, 처리해주어 로직을 처리함으로써 문제를 해결할 수 있었습니다. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:3:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"+) 비교: Debouncing이 적용되지 않은 경우 디바운싱이 적용되지 않은 경우는 다음과 같습니다. 사용자의 입력이 끝나기도 전에, 입력이 될 때마다 함수가 작동하는 것을 알 수 있죠. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:3:1","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"후일담. 그래서 실제로는 이렇게 적용했어요 디바운싱을 적용해 이제는 불완전한 RFID 번호가 들어오거나, RFID 번호가 들어오고 있는 와중에 의도치 않은 함수가 실행되는 일은 없어졌습니다. 따라서 입력된 값들만 제대로 처리할 수 있게 가공해주기만 하면 끝이었죠. 남아 있는 문제는 다음과 같았습니다. 입력된 값은 유효한 RFID 하나의 값, 혹은 다수의 RFID의 값이 포함된 값일 수 있다. 입력된 RFID 번호는 같은 값이 중복되어 입력될 수 있다. 실제로 입력된 값의 유형은, 하나의 RFID 번호 ABCDE00000000001 혹은 ABCDE00000000002 와 같은 형태 다수의 RFID 번호 ABCDE00000000001ABCDE00000000002ABCDE00000000003 과 같은 형태 혹은 ABCDE00000000001ABCDE00000000002ABCDE00000000001 과 같이 일부 중복된 형태 다음의 두 가지였습니다. RFID 번호는 각기 고유한 규격을 가지고 있습니다. 각 RFID 번호는 고유한 길이, 첫 문자부터 일정 길이까지 정해진 값, 특정 값을 가진 분류 값 등 특정 문자열 패턴을 가지고 있고 유효한 값을 분리해줄 수 있었습니다. 따라서 1. 유효한 RFID 값인가의 경우는, 어차피 별로 길지 않은 문자열이기에 문자열의 글자를 하나하나 탐색하여 길이, 문자에 올바른 위치에 고유번호가 존재하는가(slice 활용) 등으로 해결할 수 있었습니다. 아니면 정규식 을 통해 해결할 수 있는 방법도 있겠죠. 2. 중복된 값이 있는가는 그냥 RFID의 값으로 인식된 값들을 하나 씩 Set()에 넣어주어 해결했습니다. 간단하죠! 이렇게 입력의 지연이 필요한 곳에 디바운싱을 적용하고 목표했던 서비스를 만들 수 있었습니다. 여러분도 입력의 완료 후 서비스의 작동이 필요하다면 디바운싱을 활용해 보세요. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:4:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":null,"content":"반갑습니다! 캐디스푼의 아이티 블로그에 오신 것을 환영합니다!! 개발과 IT/SW의 내용과 함께, 차를 비롯한 저를 이루고 있는 것들로 채워질 공간입니다. 이렇게 만나게 되어 반갑습니다! 🤗 ","date":"2021-10-16","objectID":"/posts/2021/10/%ED%99%98%EC%98%81%ED%95%A9%EB%8B%88%EB%8B%A4/:0:0","tags":null,"title":"환영합니다.","uri":"/posts/2021/10/%ED%99%98%EC%98%81%ED%95%A9%EB%8B%88%EB%8B%A4/"}]