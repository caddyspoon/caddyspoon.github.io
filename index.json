[{"categories":["Dev","Data Structure"],"content":" 입력 상자에 입력된 어절을 기반으로, 이전에 입력한 키워드를 자동으로 완성하는 방법을 알아봅니다. 자료구조 Trie을 통해 구현할 수 있죠. 제가 정말 잘 샀다 싶은 앱들이 몇 있는데요, 편한가계부 는 그 중 하나입니다. (iOS에서는) 문자를 기반으로 사용자의 결제 내역을 자동으로 저장해주고, 일정 기간별로 통계를 보여주어 지난 한 기간에서의 지출 내용을 통한 미래 지출 계획 설계, 자가 분석 (+ 반성) 등을 도와주는 앱입니다. 그리고 각 결제 내역을 입력할 때 세부 내용을 입력할 수 있는데, 단어 조각을 입력하면 사용자가 과거에 입력했던 기록을 기반으로 입력할 내용을 찾아줍니다. 이렇게요. 특히 내가 입력했던 내용 을 찾아 보여주기 때문에, 구구절절하게 기입했던 내용 역시 잘 기억해놨다가 알아서 입력해줍니다. 저는 내용을 자세하게 적는 편인데, 예를 들어 서브웨이 터키 6인치 위트 피클류 제외 음료 없이 이라고 적거든요. 그리고 서브웨이에 가면 보통 먹었던 메뉴를 먹고요. 그 때마다 저 20음절의 어구를 직접 입력하는 것이 아니라, 서브라는 2음절만 완성해도 해당 내용을 알아서 찾아 주기 때문에 정말 편리합니다. 이와 같이 사용자가 입력했던 내용을 기반으로 자동완성해주는 기능을 구현해보도록 하겠습니다. 여러가지 방법이 있겠지만 여기서는 Trie 자료구조를 활용해보려고 합니다. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:0:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"Trie. 단어를 빠르게 찾는 자료구조 트라이 인덱싱(trie indexing) 정보·통신 가변 크기의 키 값을 다룰 때 특히 유용한 인덱스 구조. 트라이는 키 값 전체가 아니라 그 일부에 의해 각 레벨의 분기가 결정되는 차수 m≥2인 트리를 의미하며, 분기 노드와 정보 노드라는 두 종류의 노드를 갖는다. ⇒규범 표기는 미확정이다. 출처: 우리말샘 | 네이버 국어사전 사전에는 어렵게 설명 되어있네요… Trie는 Tree 구조와 유사한 형태를 가지는 자료구조입니다. 우리말 규범 표기는 미확정이지만, 영미 문화권에서는 Tree구조와 구분하기 위해 [트라이]로 읽는 것이 일반적입니다. 이 글에서는 단어를 색인하는 목적의 Trie 자료구조에 한정해서 이야기 해봅시다. Trie는 트리 구조와 유사한 형태로, 각 노드는 로마자에서는 하나의 알파벳 기준으로 만들어지며, 하나의 노드는 다음의 노드의 키가 되는 형태로 이루어진 자료구조입니다. 구문으로 풀어 쓰면 어려워 보이지만, 그림으로 보면 더 쉽게 이해할 수 있습니다. Wikipedia. “Trie”. https://en.wikipedia.org/wiki/Trie 상단의 그림을 봐볼까요? Wikipedia의 Trie 항목에서 가져온 그림입니다. Trie는 일종의 사전입니다. 위의 Trie는 A, to, tea, ted, ten, inn의 총 6개 단어가 저장된 Trie입니다. 트리구조처럼 부모 노드가 자식 노드를 갖는 형태를 가지며, 각 단어의 바로 앞선 글자가 부모가 되며 그 다음 글자가 자식이 됩니다. 또한 맨 처음 노드인 head 는 비어있습니다. 상단 그림에서 3번으로 표기된 tea 를 기준으로 해당 자료구조를 설명해보겠습니다. 안내 다음의 Trie 구현은 상황에 따라 예시일 뿐이며, 상황에 따라 다르게 사용됩니다. 본 코드에서는 Node에서 word라는 값을 사용했지만, 코드에 따라 boolean을 통해 해당 단어가 마지막인지 체크만하는 코드도 존재합니다. 각 글자(로마자의 경우 알파벳)의 경우 Node로 구성되어 있으며, 각 노드는 key, word, children으로 구성되어 있습니다. 구조를 설명하면서 완성된 단어라는 표현을 사용할 건데요, 이는 tea, ted, inn처럼 Trie에 입력되는 하나의 단어를 지칭하는 표현으로 사용하도록 하겠습니다. 먼저, 1. 최상단 부모노드 head 는 비어있습니다. 각 단어의 첫 글자는 head의 자식이 됩니다. 따라서, tea 의 첫 글자 t 는 head 의 자식이 됩니다. 노드를 기준으로 설명하면, head 노드의 key는 비어있는 노드이므로 언어에 따라 null 혹은 None 이 되고, children에는 노드 t 가 담기게 됩니다. 이 부분은 글로는 어렵지만, 아래 코드를 통해 본다면 훨씬 수월히 이해가 될 것입니다. 2. 바로 다음 글자는 앞선 글자의 자식이 됩니다. tea 의 첫 글자 t는 head의 자식인 노드가 되며 key 값으로 t라는 값을 가지게 됩니다. 두 번째 글자 e 는 첫 번째 글자인 t 의 자식이 됩니다. 또한 연쇄적으로 두 번째 글자 e는 세 번째 글자 a 의 부모가 됩니다. 노드 기준으로는 t 값을 key로 가지는 노드의 children 에 e 노드가 담기게 되고, 다시 e 를 key 로 가지는 노드는 a 노드를 children 에 담습니다. 추가적으로, 여기서 만들어진 Trie는 to 라는 단어를 가지고 있기 때문에, 그림의 7번을 보면 t는 또 다른 자식인 o를 갖는 것을 볼 수 있습니다. 3. 단어의 마지막 글자는 해당 글자가 완성되었다는 정보를 갖습니다. 완성된 단어의 마지막 글자는 해당 글자가 완성되었다는 정보를 가집니다. 노드의 관점에서 보면, 해당 노드의 word에 완성된 단어의 값을 넣습니다. 완성된 단어가 아닌 경우 각 노드의 word는 none 혹은 null 값을 가질 것이며, 해당 노드가 완성된 단어의 마지막 글자일 경우 word값으로 완성된 단어를 가질 것입니다. 여기서는 a노드의 word값에 tea라는 값이 담기게 됩니다. 노드의 word 값을 통해 해당 단어가 완성된 단어인지 즉, Trie에 이 단어가 입력이 되어있는지 판별하게 됩니다. 위의 그림을 기준으로 한다면 각 노드를 표현한 동그라미 안에 쓰여진 to, te, tea, ted 와 같은 값들이 이에 해당합니다. 다만 실제 코드에서는 완성된 단어가 아닐 경우 null 값을 넣어주고, 완성된 단어일 경우에만 해당 단어를 넣어줄 것입니다. 이 설명 역시 글로는 어렵지만, 코드를 본다면 명확히 이해가 될 것입니다. 만약 글로 해당 구조가 그려지는 분들 중 이런 의문을 가지는 분들이 있을 수 있겠습니다. “그냥 자식이 없는 노드를 기준으로 완성된 단어인지 판별하면 되는 거 아닌가?” 하지만 자식을 가지지 않는 노드가 해당 단어의 마지막 글자다라는 기준으로만 해당 글자가 완성된 단어의 마지막 글자인지 판별하게 된다면 다음과 같은 상황에서 놓치게 되는 단어들이 있을 수 있습니다. 가령 Trie에 tea 라는 단어와 tealeaf 라는 단어가 모두 포함 되어 있을 경우죠. 이 경우 a 노드는 word 에 완성된 단어인 tea 라는 가짐과 동시에 자식으로 l을 가지게 됩니다. 즉, 자식을 가지고 있는 노드지만 tea라는 완성된 단어의 마지막 노드가 되는 것이지요. 따라서 해당 노드가 자식을 가지지 않는다를 기준으로 해당 단어가 완성된 단어인가를 판별하는 것은 위험합니다. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:1:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"자 이제 코드로 봅시다! 역시 코드로 보는 게 빠르지요. 먼저 Javascript로 보도록 하겠습니다. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"1. class로 구현 // 각 단어의 글자가 담길 Node class Node { constructor(key, word = null) { // key는 각 단어의 알파벳 this.key = key; // word는 해당 key가 단어의 마지막 글자일 경우 해당 단어를 담아줍니다. // 따라서 처음 값은 null this.word = word; // children의 Object에는 자식이 되는 글자를 key로, value에는 Node를 담아줍니다. this.children = {}; } } class Trie { constructor() { // 처음 생성되는 노드인 헤드는 key 값이 비어있는 노드입니다. this.head = new Node(null); } // insert는 해당 Trie에 단어를 담는 메소드입니다. // Trie.insert(\"tea\");와 같은 형태로 Trie에 단어를 담아줍니다. insert(string) { // 위에서 보았던 그림과 같이 순차적으로 노드를 탐색합니다. // 첫 노드는 head가 됩니다. // string이 'tea'일 경우, 첫 노드는 head, 그 다음 노드는 t, 그 다음은 e이며 마지막 노드는 a일 것입니다. let currNode = this.head; // string(단어)의 각 글자를 하나하나 탐색하며 Node에 담아줍니다. for (const char of string) { // 해당 글자가 children에 처음 담기는 글자일 경우 새로운 노드를 만들어 넣어줍니다. /* * 가령 이 Trie에 'to'를 insert하고 'tea'를 insert 했다면 * 'to'의 't'는 처음 입력되는 값이므로 아래 if문에 걸려 new Node가 작동할 것이지만 * 두 번째 입력된 'tea'의 't'는 head의 자식으로 이미 존재하기 때문에 아래 가정문에 걸리지 않을 것입니다. */ if (!(char in currNode.children)) { // 현재 노드에 처음으로 생성된 자식이라면 char를 key로 하는 새로운 노드를 만들어 Object에 넣습니다. currNode.children[char] = new Node(char); } // 자식 노드를 현재 노드로 바꾸어 주고 다음 for-loop를 시행합니다. currNode = currNode.children[char]; } // for-loop가 종료되었다면, 즉 해당 currNode(현재 노드)가 마지막 글자가 되었다면, word값을 null이 아닌 string(완성된 단어)을 입력해줍니다. // 'tea'라는 단어를 insert 했다면 'a' 노드만 word 값으로 'tea'를 가지고, 't'와 'a'의 word는 null일 것입니다. currNode.word = string; } // Trie에 string이라는 값이 있는지 탐색하는 메소드입니다. search(string) { // 첫 시작노드는 head가 됩니다. let currNode = this.head; // 찾고자 하는 단어의 각 글자(로마자의 경우 알파벳)을 기준으로 하나하나 탐색합니다. for (const char of string) { // 현재 노드의 자식으로 다음 글자가 존재한다면 if (char in currNode.children) { // 다음 노드는 현재 노드로 바꾸어 줍니다. currNode = currNode.children[char]; // 다음 글자가 현재 노드의 자식으로 존재하지 않는다면 } else { // 찾고자 하는 단어가 없는 것이므로 false를 반환합니다. return false; } } // for-loop가 무사히 종료되어 마지막 노드가 현재 노드(currNode)가 됐을 경우 // 현재 노드의 word가 찾고자 하는 단어와 같다면 if (currNode.word === string) { // 해당 단어는 본 Trie에 포함되어있다는 의미의 true를 반환합니다. return true; // 그렇지 않은 경우는 해당 단어가 Trie에 없는 경우이므로 false를 반환합니다. /* * 예를 들어 Trie에 'tealeaf'라는 단어가 포함되어있지만 'tea'라는 단어가 포함되어있지 않은 경우라면 * 'tea'라는 단어를 해당 Trie에서 찾을 경우, for-loop는 무사히 수행하지만 * 해당 Trie에는 존재하지 않는 단어입니다. */ } else { // 따라서 해당 단어는 본 Trie에 포함되어있지 않으므로 false를 반환합니다. return false; } } } ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:1","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"2. function으로 구현 // 각 주석은 위의 class 코드에 적힌 주석과 똑같습니다. // 각 단어의 글자가 담길 Node const Node = function(key, word = null) { // key는 각 단어의 알파벳 this.key = key; // word는 해당 key가 단어의 마지막 글자일 경우 해당 단어를 담아줍니다. // 따라서 처음 값은 null this.word = word; // children의 Object에는 자식이 되는 글자를 key로, value에는 Node를 담아줍니다. this.children = {}; } const Trie = function() { // 처음 생성되는 노드인 헤드는 key 값이 비어있는 노드입니다. this.head = new Node(null); // insert는 해당 Trie에 단어를 담는 메소드입니다. // Trie.insert(\"tea\");와 같은 형태로 Trie에 단어를 담아줍니다. this.insert = function(string) { // 위에서 보았던 그림과 같이 순차적으로 노드를 탐색합니다. // 첫 노드는 head가 됩니다. // string이 'tea'일 경우, 첫 노드는 head, 그 다음 노드는 t, 그 다음은 e이며 마지막 노드는 a일 것입니다. let currNode = this.head; // string(단어)의 각 글자를 하나하나 탐색하며 Node에 담아줍니다. for (const char of string) { // 해당 글자가 children에 처음 담기는 글자일 경우 새로운 노드를 만들어 넣어줍니다. /* * 가령 이 Trie에 'to'를 insert하고 'tea'를 insert 했다면 * 'to'의 't'는 처음 입력되는 값이므로 아래 if문에 걸려 new Node가 작동할 것이지만 * 두 번째 입력된 'tea'의 't'는 head의 자식으로 이미 존재하기 때문에 아래 가정문에 걸리지 않을 것입니다. */ if (!(char in currNode.children)) { // 현재 노드에 처음으로 생성된 자식이라면 char를 key로 하는 새로운 노드를 만들어 Object에 넣습니다. currNode.children[char] = new Node(char); } // 자식 노드를 현재 노드로 바꾸어 주고 다음 for-loop를 시행합니다. currNode = currNode.children[char]; } // for-loop가 종료되었다면, 즉 해당 currNode(현재 노드)가 마지막 글자가 되었다면, word값을 null이 아닌 string(완성된 단어)을 입력해줍니다. // 'tea'라는 단어를 insert 했다면 'a' 노드만 word 값으로 'tea'를 가지고, 't'와 'a'의 word는 null일 것입니다. currNode.word = string; } // Trie에 string이라는 값이 있는지 탐색하는 메소드입니다. this.search = function(string) { // 첫 시작노드는 head가 됩니다. let currNode = this.head; // 찾고자 하는 단어의 각 글자(로마자의 경우 알파벳)을 기준으로 하나하나 탐색합니다. for (const char of string) { // 현재 노드의 자식으로 다음 글자가 존재한다면 if (char in currNode.children) { // 다음 노드는 현재 노드로 바꾸어 줍니다. currNode = currNode.children[char]; // 다음 글자가 현재 노드의 자식으로 존재하지 않는다면 } else { // 찾고자 하는 단어가 없는 것이므로 false를 반환합니다. return false; } } // for-loop가 무사히 종료되어 마지막 노드가 현재 노드(currNode)가 됐을 경우 // 현재 노드의 word가 찾고자 하는 단어와 같다면 if (currNode.word === string) { // 해당 단어는 본 Trie에 포함되어있다는 의미의 true를 반환합니다. return true; // 그렇지 않은 경우는 해당 단어가 Trie에 없는 경우이므로 false를 반환합니다. /* * 예를 들어 Trie에 'tealeaf'라는 단어가 포함되어있지만 'tea'라는 단어가 포함되어있지 않은 경우라면 * 'tea'라는 단어를 해당 Trie에서 찾을 경우, for-loop는 무사히 수행하지만 * 해당 Trie에는 존재하지 않는 단어입니다. */ } else { // 따라서 해당 단어는 본 Trie에 포함되어있지 않으므로 false를 반환합니다. return false; } } } 기본적인 코드는 이렇게 됩니다. 사용은 어떻게 하면 되는지 아래에서 보여드릴게요. 코드에 대한 내용은 주석을 참고해주세요. 위 코드는 주석이 많으니까 복붙해서 쓰시려는 분들은 아래 코드를 사용해주세요. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:2","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"3. 기본적인 사용 예시 const Node = function(key, word = null) { this.key = key; this.word = word; this.children = {}; } const Trie = function() { this.head = new Node(null); this.insert = function(string) { let currNode = this.head; for (const char of string) { if (!(char in currNode.children)) { currNode.children[char] = new Node(char); } currNode = currNode.children[char]; } currNode.word = string; } this.search = function(string) { let currNode = this.head; for (const char of string) { if (char in currNode.children) { currNode = currNode.children[char]; } else { return false; } } if (currNode.word === string) { return true; } else { return false; } } } // 간단한 사용 예시 코드 // new 키워드를 사용해 생성자 함수 만들기 const trie = new Trie(); // 이 단어들을 Trie에 넣어주도록 해볼게요. const stringArr = [\"apple\", \"apollo\", \"apptite\", \"appstore\", \"appdulla\"]; stringArr.forEach(string =\u003e { // 만들어진 trie에 insert 메소드를 통해 단어들을 넣습니다. trie.insert(string); }) // apple이라는 값이 이 trie에 있니? console.log(\"apple: \", trie.search(\"apple\")); // true // apollo는? console.log(\"apollo: \", trie.search(\"apollo\")); // true // 혹시 apgujeong도? console.log(\"apgujeong: \", trie.search(\"apgujeong\")); // false 이렇게 사용하면 됩니다. 역시 결과값으로 보니까 훨씬 낫네요. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:3","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"Trie를 활용해 자동완성 입력창 만들기 이제 Trie를 어느정도 쓸 수 있을 것 같으니까 실제 기능구현으로 활용해봅시다. 사용자가 입력한 값을 저장하고, 이 값을 자동완성해주는 기능을 구현해보겠습니다. 다음과 같은 입력상자가 있고 아래에 자동 완성이 되도록 만들어보겠습니다. 고맙게도 입력한 값을 기준으로 잘 나타나고 있네요. 참고로 로마자는 알파벳 기준으로 하나의 노드가 완성되지만, 한글의 경우는 완성된 하나의 음절 혹은 따로 떨어져 입력된 자소 단위로 노드가 완성됩니다. 따라서 o(이응)과 아는 전혀 상관없는 별개의 노드가 되고, o(이응)은 아의 부모노드가 되지 않습니다. 기존의 코드와는 다르게, 단어가 완성되지 않았을 때 완성될 것으로 예상되는 단어들을 보여주어야 합니다. 따라서 search() 메소드를 조금 수정했습니다. 코드는 다음과 같습니다. \u003c!-- index.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003c/head\u003e \u003cbody\u003e \u003cmain class=\"App\"\u003e \u003c/main\u003e \u003cscript src=\"trie.js\" \u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e // trie.js const $app = document.querySelector(\".App\"); const $inputBox = document.createElement(\"input\"); $app.appendChild($inputBox); const $textBox = document.createElement(\"p\"); $app.appendChild($textBox); const Node = function(key, word = null) { this.key = key; this.word = word; this.children = {}; } const Trie = function() { this.head = new Node(null); this.insert = function(string) { let currNode = this.head; for (const char of string) { if (!(char in currNode.children)) { currNode.children[char] = new Node(char); } currNode = currNode.children[char]; } currNode.word = string; } this.search = function(string) { let currNode = this.head; for (const char of string) { if (char in currNode.children) { currNode = currNode.children[char]; } else { return; } } // 현재 입력한 값을 기준으로 만들 수 있는 단어들을 넣어줍니다. let foundWords = []; // 재귀함수를 통해 현재 단어를 기준으로 만들 수 있는 단어들을 찾습니다. const recurSearch = (currNode) =\u003e { // 현재 노드에 완성된 단어가 있고 if (currNode.word) { // 찾은 단어가 아직 배열에 들어있지 않다면, 해당 단어를 삽입해줍니다. if (!(currNode.word in foundWords)) { foundWords = [ ...foundWords, currNode.word ]; } } // 현재 노드 기준으로 자식 단어를 찾습니다. for (const child in currNode.children) { recurSearch(currNode.children[child]); } } recurSearch(currNode); return foundWords; } } const trie = new Trie(); // 출력된 내용을 보여주는 코드 $inputBox.addEventListener(\"keyup\", e =\u003e { $textBox.innerHTML = null; if (e.target.value) { const results = trie.search(e.target.value); if (results) { $textBox.innerHTML = results.map(result =\u003e `\u003cp class=\"result\"\u003e${result}\u003c/p\u003e`).join(\"\") } } if (e.key === \"Enter\" \u0026\u0026 e.target.value) { trie.insert(e.target.value); $inputBox.value = null; } }) ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:3:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"Debouncing을 활용, 입력완료까지 기다렸다가 자동완성하기 입력과 동시에 자동완성을 하는 것이 아니라, 사용자의 입력이 완료되었다고 판단한 후에 자동완성을 보여주는 것이 더 보기 좋을 것 같은데 한 번 해볼까요? Debouncing을 통해 구현할 수 있습니다! 아까와는 다르게 문구가 입력된 후 일정 시간이 지났을 때만 자동완성이 노출되도록 했습니다. 오 뭔가 조금 더 깔끔해진 기분이 듭니다. Debouncing에 관한 자세한 설명은 해당 링크를 참조해주세요. Debouncing을 적용한 코드는 다음과 같습니다. const $app = document.querySelector(\".App\"); const $inputBox = document.createElement(\"input\"); $app.appendChild($inputBox); const $textBox = document.createElement(\"p\"); $app.appendChild($textBox); // Debouncing을 합니다! const debounce = (func, delay) =\u003e { let debounceTimer; return function() { const context = this; const args = arguments; clearTimeout(debounceTimer); debounceTimer = setTimeout(() =\u003e func.apply(context, args), delay); } } const Node = function(key, word = null) { this.key = key; this.word = word; this.children = {}; } const Trie = function() { this.head = new Node(null); this.insert = function(string) { let currNode = this.head; for (const char of string) { if (!(char in currNode.children)) { currNode.children[char] = new Node(char); } currNode = currNode.children[char]; } currNode.word = string; } this.search = function(string) { let currNode = this.head; for (const char of string) { if (char in currNode.children) { currNode = currNode.children[char]; } else { return; } } let foundWords = []; const recurSearch = (currNode) =\u003e { if (currNode.word) { if (!(currNode.word in foundWords)) { foundWords = [ ...foundWords, currNode.word ]; } } for (const child in currNode.children) { recurSearch(currNode.children[child]); } } recurSearch(currNode); return foundWords; } } const trie = new Trie(); $inputBox.addEventListener(\"keyup\", e =\u003e { $textBox.innerHTML = null; if (e.key === \"Enter\" \u0026\u0026 e.target.value) { trie.insert(e.target.value); $inputBox.value = null; } }) // Debouncing을 적용합니다! // 350ms를 기준으로 입력했습니다. $inputBox.addEventListener(\"keyup\", debounce(e =\u003e { if (e.target.value) { const results = trie.search(e.target.value); if (results) { $textBox.innerHTML = results.map(result =\u003e `\u003cp class=\"result\"\u003e${result}\u003c/p\u003e`).join(\"\") } } }, 350)) 지연을 주고 출력하고 싶다면, 다음과 같이 디바운싱을 활용할 수 있습니다. 지연시간을 조절하면서 목적에 맞도록 구현하면 좋을 것 같네요.😄 ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:3:1","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"마치며 해당 포스트를 작성하며 찾아보았는데, 자동완성을 구현하는 방법은 많습니다. 특정 라이브러리나 브라우저의 자동완성 기능을 활용할 수도 있고요. 본 포스트에서는 Trie 자료구조에 대해 알아보고, 이를 활용할 수 있는 하나의 예시로 자동완성에 적용해보았습니다. Trie 자료구조의 시간복잡도는 문자열 길이 m에 대해 O(m) 입니다. 다만 문자열이 공간을 많이 차지하여, 공간 복잡도는 매우 크게 나타날 수 있습니다. Trie 구조 역시 상황에 따라 필요하다고 생각될 때 올바르게 사용하는 것이 중요할 것 같습니다.🤔 ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:4:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev"],"content":" 사용자의 입력을 기다렸다가 완전히 입력이 종료되었다고 판단되면 입력을 받도록 합니다. 디바운싱을 활용해서요. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:0:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"디바운싱이란? 사용자의 입력을 받아 처리해야 합니다. 단, 사용자의 모든 입력이 종료되었을 때만 입력을 받고 엔터 키를 누르는 등 입력이 종료되었다는 별도의 액션이 없습니다. 사용자의 입력이 완료 되었음을 어떻게 알고 처리할 수 있을까요? 간단해보이지만 실제로 구현하고자 하면 생각보다 쉽지 않을 것입니다. 이러한 문제를 해결하기 위한 개념이 deboucing 입니다. 디바운싱(debouncing) 기계식 스위치의 동작을 전기적 신호로 바꿀 때 생기는 진동 잡음을 제거하기 위하여 사용하는 하드웨어의 지연 회로, 소프트웨어의 적절한 지연 시간. 출처 : 컴퓨터 인터넷 IT용어 대사전 | 네이버 사전 사전에서는 목적에 맞는 처리를 위한 소프트웨어의 적절한 지연 시간을 디바운싱이라고 정의하고 있습니다. 디바운싱이 필요한 경우는 어떤 경우이며, 또 어떻게 적용해야 할까요? 제가 디바운싱을 통해 문제를 해결했었던 경험을 통해 디바운싱에 대해 이야기 해볼까 합니다. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:1:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"문제상황. ‘RFID 코드 입력을 처리해야하는데…’ 화면에서 RFID 번호를 입력을 받아야 했습니다. RFID란 간단히 말하자면 식별이 가능한 태그입니다. 바코드와 비슷한데, 교통카드처럼 접촉으로 인식하며 상품의 종류 뿐 아니라 각 상품 하나를 인식하며 관리하기 위해 쓰이는 게 보통입니다. 가령 바코드는 \"삑! 이건 사과, 삑! 이건 바나나\"로 인식한다면, RFID는 \"삑! 이건 어제 네 번째로 들어온 청송사과, 삑! 이건 어제 첫 번째로 들어온 충주사과\" 이런 식이죠. 바코드와는 다르게 각 상품에 1:1로 매칭이 되는 것이지요. 요런 식으로 제품에 붙어있답니다.여기 붙어있는 RFID 값은 저희 집 찬장 구석에 내용물은 모두 내어주고 병만 남은 이 잭다니엘에게만 주어진 고유한 값이죠 자, 그래서 프로젝트 진행 중 RFID 코드를 입력받아야 했습니다. RFID 리더기를 사용해 RFID 태그의 입력을 받았죠. RFID 리더기나 바코드 인식기 등, 입력을 받는 기기들은 보통 입력 값을 입력해주고 자동으로 엔터를 자동으로 입력해 처리해줍니다. 그러나 RFID 리더기를 통해서 상품을 읽히는데 예상과는 다르게 입력이 되었습니다. 기대했던 작동 방식 (희망편): RFID 태그를 리더기에 인식 -\u003e RFID 번호 값이 입력된 후 자동으로 엔터 입력 -\u003e 원하는 로직 처리 -\u003e RFID 리더기에 새로운 태그 인식 (반복) 실제 작동한 방식 (절망편): RFID 태그를 리더기에 인식 -\u003e 바로 엔터가 입력되지 않고 근처에 있는 RFID 코드 값이나 방금 인식된 값이 또 입력 -\u003e 엔터 입력 -\u003e 로직 처리 중, 그러나 그 와중에도 입력되고 있는 RFID 번호 -\u003e (서비스) ‘아 잠깐만여 이 번호는 또 뭐여’ -\u003e 그 와중에도 입력되고 있는 RFID -\u003e 으어어 (반복) 이런 상황이 발생하고 있었고 실제로 입력된 값들은 다음과 같았습니다. 기대했던 입력값: AAA00000000001 (엔터) -\u003e AAA00000000002 (엔터) -\u003e A000000000003 (엔터) 실제 입력값: AAA00000000001AAA00000000002A00000000 (엔터) 두 개의 온전한 RFID 번호와 불온전한 번호 하나가 결합한 형태 문제를 요약하자면, 하나의 입력 값을 받고 바로 엔터처리가 되지 않음 다른 RFID 태그가 근처에 있으면 같이 입력됨 혹은, 방금 태그한 RFID 태그가 다시 입력 됨 엔터가 입력되고 로직이 처리되는 과정에서 RFID 값이 또 입력 돼, 끝까지 인식되지 않은 RFID 입력 값이 발생 다음의 네 가지와 같았습니다. 따라서 입력이 완료 되었다고 판단 되었을 때 로직을 실행할 것, 입력된 RFID 중 중복 값을 제거하고 올바른 RFID만 모아 처리할 것 의 두 가지 해결 목표가 생겼습니다. ‘흠, 그렇다면 먼저 첫 번째 목표인 입력이 완료되었을 때... 를 어떻게 판별하고 처리해야할까…‘의 고민 중 문제해결 방법을 찾았고 디바운싱을 적용한다면 이 문제를 해결할 수 있다는 것을 알게 되었습니다. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:2:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"디바운싱. Javascript로 구현하기 Javascript 코드를 통해 디바운싱을 구현해봅시다. 사실 자바스크립트의 라이브러리 lodash 에서 debounce 메소드를 통해 손쉽게 디바운싱을 사용할 수 있습니다. 코드 원소스: https://www.geeksforgeeks.org/lodash-_-debounce-method/ // 출처: GeeksforGeeks // Requiring lodash library const _ = require('lodash'); // Using _.debounce() method // with its parameters var debounce_fun = _.debounce(function () { console.log('Function debounced after 1000ms!'); }, 1000); debounce_fun(); 여기서는 lodash의 도움을 구하지 않고 직접 코드를 써서 사용해볼까요. 코드 원소스: https://www.geeksforgeeks.org/debouncing-in-javascript/?ref=gcse // 출처: GeeksforGeeks const debounce = (func, delay) =\u003e { let debounceTimer return function() { const context = this const args = arguments clearTimeout(debounceTimer) debounceTimer = setTimeout(() =\u003e func.apply(context, args), delay) } } clearTimeout() 메소드는 이전에 생성되어 사용된 setTimeout() 을 취소하는 메소드입니다. 디바운싱 함수는 클로저를 이용한 형태로 만들어져있습니다. 따라서 함수 debounce의 실행 컨텍스트가 종료된 뒤에도 선언된 변수 debouncerTimer 는 사라지지 않고, setTimeout의 delay 시간이 남아있는 상태에서 또 다시 setTimeout의 delay 시간만큼 실행하고자 하는 함수 func를 기다리는 대상이 됩니다. 해당 내용은 기회가 된다면 따로 다루는 것이 좋겠네요. 간단하게 디바운싱이 작동하는 페이지를 만들어 봅시다. input 상자가 있고, 상자에 입력하는 문구가 하단에 기입이 되게 할 것입니다. 텍스트의 입력을 기다리고, 입력이 완료됐다고 판단되면 텍스트가 출력되는 디바운싱을 구현해봅니다. 실제는 이렇게 작동합니다. 입력이 완료될 때까지 잘 기다리고 있다가 작동하네요. 상황에 따라서 실시간으로 입력을 받거나, 디바운싱을 받거나 선택해서 사용하면 되겠지요. 코드는 다음과 같습니다. \u003c!-- index.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003c/head\u003e \u003cbody\u003e \u003cmain class=\"App\"\u003e \u003c/main\u003e \u003cscript src=\"debounce.js\" \u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e // debounce.js const $app = document.querySelector(\".App\") const $inputBox = document.createElement(\"input\") $app.appendChild($inputBox) const $textBox = document.createElement(\"p\") $app.appendChild($textBox) // 실제 Debouncing 관련 코드 const debounce = (func, delay) =\u003e { let debounceTimer return function() { const context = this const args = arguments clearTimeout(debounceTimer) debounceTimer = setTimeout(() =\u003e func.apply(context, args), delay) } } // 500ms의 지연시간을 준 debouncing $inputBox.addEventListener(\"keydown\", debounce(e =\u003e { $textBox.innerHTML = e.target.value }, 500)) 입력 지연시간은 실제로 서비스에 적용하면서 가장 적절한 값을 찾는 게 좋겠네요. 200, 300ms 혹은 여유있게 1초(1000ms)를 지연하는 것도 상황에 따라 괜찮을 것 같습니다. 다음과 같은 디바운싱으로 RFID 리더기의 입력 값을 기다리고 모든 인식이 끝났을 때 문자열을 입력, 처리해주어 로직을 처리함으로써 문제를 해결할 수 있었습니다. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:3:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"+) 비교: Debouncing이 적용되지 않은 경우 디바운싱이 적용되지 않은 경우는 다음과 같습니다. 사용자의 입력이 끝나기도 전에, 입력이 될 때마다 함수가 작동하는 것을 알 수 있죠. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:3:1","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"후일담. 그래서 실제로는 이렇게 적용했어요 디바운싱을 적용해 이제는 불완전한 RFID 번호가 들어오거나, RFID 번호가 들어오고 있는 와중에 의도치 않은 함수가 실행되는 일은 없어졌습니다. 따라서 입력된 값들만 제대로 처리할 수 있게 가공해주기만 하면 끝이었죠. 남아 있는 문제는 다음과 같았습니다. 입력된 값은 유효한 RFID 하나의 값, 혹은 다수의 RFID의 값이 포함된 값일 수 있다. 입력된 RFID 번호는 같은 값이 중복되어 입력될 수 있다. 실제로 입력된 값의 유형은, 하나의 RFID 번호 ABCDE00000000001 혹은 ABCDE00000000002 와 같은 형태 다수의 RFID 번호 ABCDE00000000001ABCDE00000000002ABCDE00000000003 과 같은 형태 혹은 ABCDE00000000001ABCDE00000000002ABCDE00000000001 과 같이 일부 중복된 형태 다음의 두 가지였습니다. RFID 번호는 각기 고유한 규격을 가지고 있습니다. 각 RFID 번호는 고유한 길이, 첫 문자부터 일정 길이까지 정해진 값, 특정 값을 가진 분류 값 등 특정 문자열 패턴을 가지고 있고 유효한 값을 분리해줄 수 있었습니다. 따라서 1. 유효한 RFID 값인가의 경우는, 어차피 별로 길지 않은 문자열이기에 문자열의 글자를 하나하나 탐색하여 길이, 문자에 올바른 위치에 고유번호가 존재하는가(slice 활용) 등으로 해결할 수 있었습니다. 아니면 정규식 을 통해 해결할 수 있는 방법도 있겠죠. 2. 중복된 값이 있는가는 그냥 RFID의 값으로 인식된 값들을 하나 씩 Set()에 넣어주어 해결했습니다. 간단하죠! 이렇게 입력의 지연이 필요한 곳에 디바운싱을 적용하고 목표했던 서비스를 만들 수 있었습니다. 여러분도 입력의 완료 후 서비스의 작동이 필요하다면 디바운싱을 활용해 보세요. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:4:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":null,"content":" Toast UI Editor를 React에 적용하는 과정을 기록했습니다. WSYWIG는 What You See Is What You Get의 줄임말로, WSYWIG 에디터는 말 그대로 작성한 대로 보이는 에디터입니다. 블로그나 게시판 글 작성에서 흔히 쓰이는, 스타일을 직접 수정하고 글을 작성하는 그런 에디터 말이지요. 본 글은 WSYWIG 에디터 중 한 종류인 Toast UI Editor를 리액트 개발환경에 적용한 기록입니다. ","date":"2022-01-05","objectID":"/posts/2022/01/0105_%ED%86%A0%EC%8A%A4%ED%8A%B8%EC%97%90%EB%94%94%ED%84%B0/:0:0","tags":null,"title":"토스트에디터 리액트 적용기 1","uri":"/posts/2022/01/0105_%ED%86%A0%EC%8A%A4%ED%8A%B8%EC%97%90%EB%94%94%ED%84%B0/"},{"categories":null,"content":"서론: WYSIWYG 에디터 \u0026 Toast UI Editor 프로젝트 중 WSYIWIG 에디터가 필요하게 됐습니다. 그리고 리액트 환경에서의 인기 WSYIWIG 에디터들은 대략 다음과 같은 에디터들이 있는 걸 알게 되었습니다. Draft Editor Quill Editor ckEditor 5 Summer Note 그 중 가장 눈에 들어왔던 것은 Draft Editor. 페이스북에서 사용하는 에디터인데, 드래프트 에디터와 React 모두 페이스북에서 만들어졌으니 참으로 찰떡이로다 라는 리뷰를 보고 Draft Editor를 적용하려 했습니다. 그러나 오잉, 생각지도 못했던 문제 발생. 한글 입력 이슈였습니다. 조합형인 한글 특성상, 커서가 아직 작성 중인 한글에 존재하는 데 Shift + Enter1를 입력하면, 입력 중이던 내용이 모두 날아가 버리는 것입니다. Quill Editor 역시 마찬가지였고, ckEditor의 경우 오픈소스 정책상 문제가 있을 수 있다고 판단해 보류했습니다. 그러던 중 발견한 Toast UI Editor. “오픈소스 WYSIWIG 에디터, NHN이 개발? 이거면 한글 날아갈 일은 없겠는데?” 한글 환경에서의 가장 안정적인 에디터로 판단했고, 이에 프로젝트에 적용하기로 했죠. ","date":"2022-01-05","objectID":"/posts/2022/01/0105_%ED%86%A0%EC%8A%A4%ED%8A%B8%EC%97%90%EB%94%94%ED%84%B0/:1:0","tags":null,"title":"토스트에디터 리액트 적용기 1","uri":"/posts/2022/01/0105_%ED%86%A0%EC%8A%A4%ED%8A%B8%EC%97%90%EB%94%94%ED%84%B0/"},{"categories":null,"content":"Toast UI Editor 적용하기 Toast UI Editor Github: https://github.com/nhn/tui.editor 리액트 에디터: https://github.com/nhn/tui.editor/tree/master/apps/react-editor 에디터 가이드: https://nhn.github.io/tui.editor/latest/ Toast UI Editor(TUI 에디터)를 리액트 프로젝트에 적용하는 방법은 그렇게 어렵지 않습니다. 한국 공식 가이드를 따라하기만 하면 되니까요. 먼저 리액트 환경에 에디터를 설치해줍니다. 여기서는 npm을 사용하겠습니다. npm install --save @toast-ui/react-editor 이제 TUI 에디터를 불러와줍니다! import '@toast-ui/editor/dist/toastui-editor.css' import { Editor } from '@toast-ui/react-editor' 몇 가지 옵션 값을 주어 컴포넌트로 만들었습니다. 전체 코드는 다음과 같습니다. // EditorComponent.js // Properties 및 API 가이드: https://nhn.github.io/tui.editor/latest/ import React from 'react' // Toast-ui-Editor import '@toast-ui/editor/dist/toastui-editor.css' import { Editor } from '@toast-ui/react-editor' import \"./EditorComponent.scss\" function EditorComponent() { return ( \u003cdiv className=\"Editor__Wrapper\"\u003e \u003cEditor initialValue=\"Hello, React World!\" // 초기 입력 문구 previewStyle=\"vertical\" // 프리뷰 스타일 ['tab', 'vertical'] height=\"600px\" // 에디터 높이값 initialEditType=\"markdown\" // 페이지 로드 시 기본 에디터 타입 /\u003e \u003c/div\u003e ) } export default EditorComponent // EditorComponent.scss .Editor__Wrapper { width: 720px; margin-inline: auto; } 전체 Properties를 비롯한 API에 대한 설명은 https://nhn.github.io/tui.editor/latest/ 페이지에서 찾아볼 수 있습니다. 이제 기본적인 사용을 위한 준비가 모두 되었습니다. 다음 글에서는 해당 컴포넌트를 사용해 프로젝트에서 활용했던 내용을 적어보겠습니다. 엔터 입력 시 \u003c/p\u003e\u003cp\u003e가 자동 생성되어 줄 간격이 너무 넓어져 , 해당 커맨드를 통해 \u003cp\u003e를 새로 삽입하지 않고 줄 바꿈이 가능합니다. ↩︎ ","date":"2022-01-05","objectID":"/posts/2022/01/0105_%ED%86%A0%EC%8A%A4%ED%8A%B8%EC%97%90%EB%94%94%ED%84%B0/:2:0","tags":null,"title":"토스트에디터 리액트 적용기 1","uri":"/posts/2022/01/0105_%ED%86%A0%EC%8A%A4%ED%8A%B8%EC%97%90%EB%94%94%ED%84%B0/"},{"categories":null,"content":"반갑습니다! 캐디스푼의 아이티 블로그에 오신 것을 환영합니다!! 개발과 IT/SW의 내용과 함께, 차를 비롯한 저를 이루고 있는 것들로 채워질 공간입니다. 이렇게 만나게 되어 반갑습니다! 🤗 ","date":"2021-10-16","objectID":"/posts/2021/10/%ED%99%98%EC%98%81%ED%95%A9%EB%8B%88%EB%8B%A4/:0:0","tags":null,"title":"환영합니다.","uri":"/posts/2021/10/%ED%99%98%EC%98%81%ED%95%A9%EB%8B%88%EB%8B%A4/"}]