[{"categories":["Diary"],"content":"2022년에 대한 회고를 적는다. 2022년이 2개월 지난 2월 22일에 적어본다. 그냥 뭔가 2가 많은게 재밌어서. 개인적인 이야기라, 평소 경어로 쓰던 포스트들과는 다르게 그냥 평어로 적어볼까 한다. 사실 개발 블로그에 별로 개인적인 이야기를 하고 싶진 않았지만, 조금 하소연이 하고 싶기도 하고… 지금의 기억이 나중에 ‘그랬었지’란 한 때의 씁쓰름했던 청승으로 기억되길 바라는 마음에 글을 적어두고 싶었다. 솔직히 말하자면 취업을 위한 블로그이기도 하고, 2022년 취업 활동에 대한 이야기를 위주로 적게 될 것 같다. 뭐 대단한 청사진을 가지고 적는 글도 아니고 하니, 두서 없이 글을 적어 나갈 것 같다. ","date":"2023-02-22","objectID":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/:0:0","tags":["life-log"],"title":"2022년 회고, 부제 '취업 대실패쇼, 그러나'","uri":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/"},{"categories":["Diary"],"content":"1. 실패…라기보단 잘 안됐지 뭐야 나름대로 성실히 살았다. 그래도 2022년은 많이 성실히 살려고 노력했다. 하지만 바랐던 취업엔 실패했다. 사실 나는 중고 신입으로 취업 시장에 도전하고 있다. 소위 SI라 말하는 개발 업종에 종사하고 있고, 만족스럽지 않다. 일정이 중요시 되는 개발… 아니 근무 환경. 코드 리뷰나 서로의 정보공유 없이 주어진 업무를 해결하며 일정을 맞춰 나가기 위한 근무 환경 속에 있기 때문이다. ‘내가 짠 코드가 잘 된 건가?‘하는 수 많은 걱정과 고민은 짧은 시간 속에 산더미처럼 쌓인 과업들에 의해 묻어져갔다. 각자의 업무가 바쁜 환경에서 현재 나의 실력에 대한 피드백을 요구하는 것은 바쁜 팀원들의 시간을 뺏는 시간이 될 뿐이었기 때문이다. 투입된 프로젝트는 유래없이 무너져가며, 숱한 야근과 주말근무에 몸까지 지쳐갔다. 배우는 것이라도 있으면 그렇게까지 지치진 않았을텐데, 지친 마음이 몸을 더 지치게했다. 그래도 큰 회사의 계열사니까 괜찮은 면이 있겠지 했던 희망은 온데간데 없고 지친 자신만 남아있었다. 그런 나를 위해 내가 고를 수 있는 선택지는 단 한가지였다. 엑소더스!!! 지옥 같았던 상반기 프로젝트 중에는 심야, 심지어는 새벽에 이루어진 퇴근에도 무언가 하기 위해 노력을 했다. 조금이라도 코드를 짜보며 공부하기, 자바스크립트, CS 관련 책보기, 기타 등등등 그렇게 상반기가 지나고, 하반기가 되어 조금씩 지난 번과는 달랐던 결과들이 나오기 시작했다. 결국은 실패에 가까운 결과였지만. ","date":"2023-02-22","objectID":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/:1:0","tags":["life-log"],"title":"2022년 회고, 부제 '취업 대실패쇼, 그러나'","uri":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/"},{"categories":["Diary"],"content":"그래서, 아무튼 잘 안된 것들 이 캡쳐만 보면 아직도 눈물이 나… 따흑🥲😩😫😭😭😭😭 카카오 블라인드 공채 최종면접에서 최종 탈락했다. 탈락한 데에는 여러가지 이유가 있겠지만, 면접에 한해서만 생각해본다면 개발을 좋아하는가에 대한 답변에 제대로 답변하지 못했던 것이 가장 컸던 것 같다. 나는 개발을 좋아한다. 그렇지 않으면 여기까지 오지 못했겠지. 밤 늦게, 혹은 새벽에 하루 일정이 끝났더라도 뭔가를 하나 더 보려고 했던 노력은 개발 자체에 대한 욕심과 즐거움이 아니었으면 못했을 것이다. 내가 가진 면접에 관한 안 좋은 버릇 중 하나는 면접관을 설득하기 위해 객관적인 자료를 제시하거나 그러한 정제된 사례를 먼저 떠올려 대답하는 것이다. 아무래도 가장 공적인 자리 중 하나이기에, 나 스스로가 나도 모르게 그렇게 되는 것이 아닐까 싶다. 지금와서 생각해보면 조금은 감정적인 진솔한 답변을 했으면 더 좋지 않았을까 싶다. 처음으로 오셀로 로직을 코드로 짤 때, 이왕 이렇게 된 거 제대로 만들어볼까하며 오셀로 게임을 만들었던 일, 자연어 분석을 구현하면서 이게 될까 싶었지만 어떻게든 문서를 찾아가며 구현하며 나 스스로도 너무 신기하고 재밌었던, 대단하지 않지만 개인적이고 솔직한 경험과 느낌을 전달하지 못한 것이 너무 아쉬움이 남는다. 아무튼 면접에서 그 질문 뒤로 자신감이 떨어져 스스로도 이해못할 이야기를 해나가며, 면접을 하는 게 아니라 주어진 질문에 되는대로 답을 하는 최악의 면접을 하고 말았다. ‘나, 바보같이 질문에 맞지 않는 이야기만 하고 있네’라고 느끼면서 면접 중에도 자신감이 점점 떨어져 제대로 된 답을 하지못한 석연찮음만 쌓아 가며 면접을 마치고 말았다. 그리고 결과는 아니나 다를까… 다른 많은 사람들이 그렇듯 ‘카카오 코테나 봐볼까’하는 가벼운 마음으로 지원했다가 어쩌다보니 1차 코테, 2차 코테를 통과하고 기술면접까지 통과하면서 ‘이거 혹시…?‘하는 기대감이 생겼다. 아주 크게. 그런데 그렇게 기대감이 커져버리니 마지막 실망감도 어쩔 수 없이 컸다. 카카오 말고도 몇 기업들의 전형들도 진행했었다. 모두 훌륭한 기업들이었고 감사하게도 몇 과정들이 나에게 허락되었지만, 각 전형에서 부족한 부분들이 많아 잘 되지 않았다. 하지만 그 과정에서의 부족한 부분들을 깨달았던 것이 큰 자양분이 되었다. 카카오는 내가 지원했던 모든 기업 전형 중 가장 마지막에 일정이 진행됐던 기업이었다. 때문에 가장 경험치가 쌓인 상태에서 전형을 진행한 기업이었고, 잘 안되긴 했지만 최종 면접까지 갔었던 것이 아닌가 싶다. 너무 아쉬운 경험이었다. 하지만 면접이 끝날 때마다 느끼듯, 그 과정에서 준비한 것들은 어디 가지 않는다. 아쉬움은 아쉬움으로 남겨두고 부족했던 부분들을 모아 더 갈고 닦아 앞으로 나아가자. ","date":"2023-02-22","objectID":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/:1:1","tags":["life-log"],"title":"2022년 회고, 부제 '취업 대실패쇼, 그러나'","uri":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/"},{"categories":["Diary"],"content":"2. 하지만, 이뤄낸 소중한 것들 2022년에 이뤄낸 것들 중 보람찬 것들이 있다. 특히, 여기서 자랑하고 싶은 이유는 꾸준함과 성실함으로 이루어낸 것들이기 때문이다. ","date":"2023-02-22","objectID":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/:2:0","tags":["life-log"],"title":"2022년 회고, 부제 '취업 대실패쇼, 그러나'","uri":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/"},{"categories":["Diary"],"content":"1. 10개월간의 (준)1일 1커밋 작년 5월부터 계속되는 끔찍한 야근과 주말출근에 이렇게는 안되겠다고 정신차린 후 1일 1커밋을 실천해봤다. 여타 1일 1커밋을 실천하시는 분들이 그렇듯, 이걸로 뭘 어디서 점수를 더 받겠다 이런 건 아니고 매일 공부나 기억해야 할 기록들을 정리하는, 최소한의 동기부여를 위해 실천했다. 실제로도 기록된 커밋들은 알고리즘 문제 풀이, 자바스크립트로 SPA로 구현하기 같은 정말 자잘한 프로젝트, 차후 생각해볼만한 업무에 대한 기록 등 다양한 커밋을 진행했다. CS 공부 내용은 공통적이고 간단한 내용이 많은데, 블로그 글로 쓰기에는 이미 다른 블로그에 너무 많이 다루어져서 ‘나까지 블로그에 올리면 인터넷 공해 수준이 아닐까?’ 싶어 너무 간단한 CS 공부 내용 등은 그냥 내용만 정리해놓았다. 아무튼 나만의 공부 연습장을 만든 느낌이라 보람있는 과정이었다. 그리고 왜 (준準)이냐면… 8월 중에는 이틀정도 이빨이 빠져있는데 리액트로 토이 프로젝트를 만드려다가 너무 복잡하게 꼬여서 만들어 놓은 레퍼지토리를 없애고 새로 만든다는게 그만… 😂 채우려면 채울 수 있겠지만 그냥 그렇게 두었다. 잔디가 너무 오밀조밀하는 것도 인간미 없어. 떼잉. ","date":"2023-02-22","objectID":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/:2:1","tags":["life-log"],"title":"2022년 회고, 부제 '취업 대실패쇼, 그러나'","uri":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/"},{"categories":["Diary"],"content":"2. 듀오링고 350일+ 연속 학습 개발얘기는 아니고 다른 공부 이야기. 1일 1커밋을 시작한 것과 거의 비슷한 시기에 듀오링고 학습을 시작했다. 스샷에는 일본어로 되어있지만 영어로 시작해 지금은 거의 일본어를 학습하고 있다. 영어 학습팩을 다 해버려서… 한국어-일본어 학습이 지원되지 않아 영어-일본어로 하고 있는데, 어떻게 보면 영어 학습이라고 봐도 되려나. 사실 연속으로 며칠하자! 하는 그런 거창한 목표는 없었다. 근데 듀오링고 자체에서 그날 학습을 하나 완료하면 연속 학습 일수를 온갖 화려한 애니메이션과 함께 보여주며 학습을 독려하는데, 이걸 어떻게 참아. 그렇게 하루하루 하다보니 어느덧 350일이 되었다. 사실 오늘 351일을 채웠는데 350을 맞춘 게 예쁘니까 오늘자 학습을 하기 전에 찍었다. 듀오링고 앱의 학습 플랜 자체는 그렇게 큰 학습 효과를 기대하긴 힘들다. 아무리 어려운 코스도 기초 단계 정도이기도 하고. 그래도 언어라는 것이 매일 접하는 것만으로도 큰 의미가 있어 하루 루틴으로 꾸준이 지속해왔다. 좋아하는 가사 문구가 하나있다. a giant step each. Spritualized의 곡 Ladies and gentlemen We are floating in space에 나오는 문구다. 그처럼 무언가가 될, 조그마한 작은 발걸음이 되지 않았을까. ","date":"2023-02-22","objectID":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/:2:2","tags":["life-log"],"title":"2022년 회고, 부제 '취업 대실패쇼, 그러나'","uri":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/"},{"categories":["Diary"],"content":"3. 10개월 연속 러닝 러닝을 10개월 연속으로 진행 중이다. 원래는 ‘XX주 연속 달리기!‘를 달성하고 싶었지만 12월 1일, 영하 5도 날씨에서 달리기를 했는데 영하 날씨에서의 첫 달리기여서 그런가 발목을 그만 우지끈 해버렸다. 추운 날씨 + 페이스 욕심 + 장거리 달리기라는 세 요소가 합쳐져서 만들어진 악재였다. 병원에서 괜찮다고 할 때까지 휴식 후, 1월부터 다시 천천히 달려보고 있다. 아무튼 역시 5월부터 달리기를 시작해서 10개월 동안 유지 중인 루틴 중 하나다. ‘개발자로서 성장하기’라는 긴 여정을 위해서는 멘탈을 뒷받침할 체력이 필요하다… 같은 거창한 이유로 시작한 것은 아니고, 그냥 30분 동안 쉬지 않고 달려보고 싶었다. 모 커뮤니티에서의 글을 하나 봤다. 글쓴이 본인이 40대의 나이로 접어들었는데 마땅한 운동을 하는 것이 없다는 것이다. 그래서 러닝을 해보자 했고, 한 러닝 앱의 8주 30분 달리기 프로그램이 유명하다길래 그대로 따라해봤다, 그랬더니 진짜 돼더라라는 글이었다. 글을 보고나니 나도 30분 동안 쉬지 않고 달리기를 해보고 싶더라. 살면서 그렇게 오랫동안 달려본 적이 없었다. 그런데 이따금씩, 그냥 생각없이 달려보고 싶을 때가 있었다. 궁금했다. ‘내가 30분 동안 쉬지 않고 달릴 수 있을까?’. 그래서 해봤다. 처음엔 10분, 15분 동안 달리기도 힘들었던게, 신기하게도 20분, 25분 달리기가 되더라. 그리고 어느덧 30분 동안 쉬지 않고 달리기를 성공했다. 뭔가 생각보다 엄청난 성취감은 없었는데, 그래도 해냈다는 기쁜 마음은 확실히 기억에 남았다. 그렇게 목표했던 30분 달리기를 완주하고 더 나아가 달려보자 해서 지금은 50분 달리기 플랜도 완료했다. 그 직후에 욕심이 나서 좀 더 빠르게 50분을 달려보려고 무리한 게 실수였지만. 사람이란 게 참 신기하다. 뭔가 꾸준히 조금씩 하다보면 어느순간 그것을 넘어선 어떠한 지경에 다다른다. 그 사실을 또 다시 확인하게 한 경험이었다. 꾸준히 러닝을 하다보니 하나 알게 된 것이 있다. 천천히 달리면 평소보다 더 먼 곳을 달릴 수 있다는 것이다. 같은 체력이어도 천천히 페이스를 조절하다보면, 이윽고 같은 체력으로도 뛰지 못했던 거리보다 더 먼 곳을 갈 수 있다. 지금 하고 있는 공부도 그렇겠지, 아무리 천천히 하다보면 어느 순간 어느덧 이루고자 목표에 다다를 것이다… 같은 뻔한 이야기를 쓰려고 한 건 아니고. 뻔한 소리 할 거면 애초에 글 적지도 않았어. 빨리 달리기는 힘들다. 근데, 또 러닝을 하다보니 알게 된 게 있는데 빨리 달리면 힘들어도 그냥 어느순간 달려진다. 익숙해진다. 게다가 빨리 달리면, 뭐 빨리 도착하겠지. 그냥 힘들 뿐이더라. 그 힘든 것만 참으면 된다. 그래 솔직히 다칠 수도 있어. 나도 불과 두 달 전에 그랬고. 다치면 쉬면 된다. 그리고 또 일어나 달리면 된다. 그러고 나니 생각이 들었다. 그래, 계속 빨리 뛰어보자. 천천히 꾸준히가 나쁘다는 얘기를 하는 것은 아니다. 토끼와 거북이의 교훈을 누구도 부정하지 못할 것이다, 나도 그렇고. 다만 누군가는 빨리 달릴 때의 그 힘듦을 버틸 수 있고, 그렇게 숨가쁘게 달리는 편이 성미에 맞을 수 있다. 그리고 나는 그 성향에 가까운 것 같다. 지금은 빠르게 달려보자. 작년은 그렇게 원하던 프론트엔드 개발자로의 전직에 실패했다. 취업은 작년의 내가 가장 많이 신경썼던 부분이고, 그래서 그런가 솔직히 많이 다쳤다. 일어날 수가 없을 것 같이 힘들게 다쳤었다. 나름대로 최선을 다한다고 생각하며 열심히 달려서 그랬을까. 하지만 다시 달려보려고 한다. 실패…일까? 아무튼 잘 되지 않았던 2022년과는 다른 2023년을 만들고 싶다. 그러기 위해 다시 일어나 빠르게 달리고 싶다. 가보자고🏃‍♂️ ","date":"2023-02-22","objectID":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/:2:3","tags":["life-log"],"title":"2022년 회고, 부제 '취업 대실패쇼, 그러나'","uri":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/"},{"categories":["Diary"],"content":"3. 2022년, 끝 뭔가 전형에 끝에서 ‘거의 다왔나?’ 싶은 곳에서 떨어져서 너무 아쉬웠다. 하지만 그냥 아쉬움으로만 기록될 해는 아니었던 것 같다. 아무튼 최종까지 간 전형이 있으니까, 그만큼은 성장하고 인정받은 것이 아닐까? 지나간 것은 나에게 남은 하나의 의미로 두자. 엘사도 얼음성 만들면서 말하잖아, The past in the past. 그냥 아쉬워만 하기에는 나름대로 스스로 어깨를 두들겨 주고 싶은 기특한 일들도 많이 했다. 여기에 적힌 성실하게 며칠을 이어나간 일들도 그렇고, 기록하지 않은 몇가지 일들도 그렇고. 아무튼 2022년에 했던 노력들은 사라지지 않는다. 어딘가, 더 나은 내가 될 흔적으로 남을 것이다. 그러니까 2023년도 다시 열심히 달려보자. 남아 있는 힘이 된다면, 되도록 빨리 달려보고 싶다. 가보자고 2023 씽씽씽. ","date":"2023-02-22","objectID":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/:3:0","tags":["life-log"],"title":"2022년 회고, 부제 '취업 대실패쇼, 그러나'","uri":"/posts/2023/02/0222_2022%EB%85%84_%ED%9A%8C%EA%B3%A0/"},{"categories":["Dev"],"content":"표 병합 문제를 풀어보려고 합니다. 개인적으로는 2023 카카오 문제팩에서 제일 재미있게 해결한 문제입니다. 프로그래머스의 2023 KAKAO BLIND RECRUITMENT 문제팩 필터를 통해 찾아볼 수 있으며, 🚀여기를 클릭하면 바로 이동할 수 있습니다. 제 코드는 가장 이상적인 해법이 아닙니다. 다만 저의 생각과 코드 작성의 방식을 공유하고자 글을 작성해봅니다.😋 ","date":"2023-01-31","objectID":"/posts/2023/01/0131_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_05_%ED%91%9C_%EB%B3%91%ED%95%A9/:0:0","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표 병합 (Python)","uri":"/posts/2023/01/0131_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_05_%ED%91%9C_%EB%B3%91%ED%95%A9/"},{"categories":["Dev"],"content":"문제 🚀표 병합 참고 링크 | 프로그래머스의 문제를 외부에 게시할 수 있나요? ","date":"2023-01-31","objectID":"/posts/2023/01/0131_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_05_%ED%91%9C_%EB%B3%91%ED%95%A9/:1:0","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표 병합 (Python)","uri":"/posts/2023/01/0131_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_05_%ED%91%9C_%EB%B3%91%ED%95%A9/"},{"categories":["Dev"],"content":"풀이 ","date":"2023-01-31","objectID":"/posts/2023/01/0131_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_05_%ED%91%9C_%EB%B3%91%ED%95%A9/:2:0","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표 병합 (Python)","uri":"/posts/2023/01/0131_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_05_%ED%91%9C_%EB%B3%91%ED%95%A9/"},{"categories":["Dev"],"content":"1. 해결 아이디어 주어진 대로 구현해보기 입력 값과 명령어를 주고 이를 수행할 수 있도록 하는 프로그램을 만드는 문제입니다. 이런 문제 해결은 개인적으로는 일단 코드를 만들어가면서 구현 과정을 확인해가면서 코드의 완성도를 높이는 편이 좋았습니다. 개발에서 ‘‘이렇게 되지 않을까’‘라는 걱정에 미리 대비책을 모두 찾아 대비하는 경우보다, ‘일단 해보기’가 더 나은 결과를 만드는 경우가 있지 않았나요? 적어도 이 문제에서만큼은 그랬었던 것 같습니다.🕺 1. UPDATE 구현하기 표에서 값을 찾고 새로운 값으로 바꾸어 줍니다. 같은 UPDATE에서도 두 종류의 업데이트가 존재하는데, 하나는 값을 기준으로 하는 UPDATE, 다른 하나는 기존 셀의 값을 기준으로 다른 모든 값을 찾아 바꾸어주는 UPDATE입니다. 표의 크기는 50 * 50입니다. 2,500개 칸을 가진 표네요. commands의 길이는 1,000개. 천 번의 명령 모두 모든 셀을 방문한다고 생각하면 2,500,000번입니다. 모든 셀 순회, 할 만 할지도…? UPDATE는 모든 셀을 돌면서 해당 하는 값을 찾고, 그 값을 찾아주는 방식으로 구현해봅시다. 2. MERGE 구현하기 자 이제 MERGE를 구현합시다. 사실 이 문제의 핵심은 MERGE와 UNMERGE를 얼마나 잘 구현하는가입니다. 선택한 두 셀은 서로 인접하지 않을 수도 있습니다. 이 경우 (r1, c1) 위치의 셀과 (r2, c2) 위치의 셀만 영향을 받으며, 그 사이에 위치한 셀들은 영향을 받지 않습니다 MERGE는 다른 두 셀을 병합합니다. 주의사항은 문제에서의 예시는 인접한 두 셀을 기준으로 나타내고 있지만 실제로는 위치상 완전히 떨어져 있는 두 셀을 병합할 수도 있다는 사실이죠. 그리고 MERGE를 반복하는 경우를 생각해보면 알 수 있지만, 미리 병합된 셀을 다른 셀과 병합하면 2개 초과의 셀들이 하나의 셀로 합쳐질 수도 있습니다. 이를 주의해서 구현해야겠네요. 두 셀 중 한 셀이 값을 가지고 있을 경우 병합된 셀은 그 값을 가지게 됩니다. 두 셀 모두 값을 가지고 있을 경우 병합된 셀은 (r1, c1) 위치의 셀 값을 가지게 됩니다. 병합된 셀들의 값을 어떻게 지정할 것인가에 대한 정의입니다. 무려 두 줄에 걸쳐서 설명하고 있네요. 분기 처리를 얼마나 잘 할 수 있는가를 묻는 문항이겠네요. 이는 간단하게 경우의 수를 세보면 금방 간단히 정의할 수 있습니다. (r1, c1)에 존재하는 값을 value1, (r2, c2)에 존재하는 값을 value2라고 했을 때 value1 미존재, value2 미존재 아무도 값이 없네요. 그냥 넘어갑니다. value1 존재, value2 미존재 값이 있는 value1의 값으로 합병합니다. value1 존재, value2 존재 두 셀 모두 값을 가지고 있을 경우 value1의 값으로 병합한다고 되어있네요. value1을 넣어줍시다. value1 미존재, value2 존재 값이 존재하는 value2의 값을 병합한 셀들에게 넣어줍니다. 정리하자면 네 가지의 케이스 중 4번 케이스를 제외하면 value1의 값을 각 셀들에 넣어주면 되겠네요. 즉, value2의 값이 있고 value1의 값이 없을 때만 value2의 값을 넣어주는 분기 처리를 해주고 그 이외에는 모두 value1을 넣어주도록 하겠습니다. 다시 어떻게 셀들을 병합할까에 대한 고민으로 돌아가 볼까요? MERGE된 셀들의 핵심은 하나의 셀이 변경되어도, 병합된 셀들의 값이 역시 변경되는 점이죠. 이 부분은 간단히 해결할 수 있습니다. 각 셀들의 값들을 참조형으로 만들면 됩니다. 표를 만들 때 # 문제에서 값이 존재하는 경우 한 글자 이상의 단어라고 정의 되었기 때문에, 빈값의 경우 ''으로 표현 가능 table = [['' for _ in range(51)] for _ in range(51)] # '' 대신, 다음과 같이 None으로 명시해주어도 된다. table = [[None for _ in range(51)] for _ in range(51)] 요런 식으로 생성하게 될텐데, 이 때 위처럼 비어있는 스트링이 아닌 table = [[[''] for _ in range(51)] for _ in range(51)] # 다음과 같이 명시해주어도 된다. table = [[[None] for _ in range(51)] for _ in range(51)] 다음과 같은 리스트[]를 씌워준 형태를 셀의 값으로 지정하는 것입니다. 그렇게 될 경우 해당 셀의 값은 특정 스트링이 아닌 해당 주소값을 가진 리스트를 바라보게 됩니다. 따라서, 다른 셀에서 해당 리스트의 값이 변경되면, 다른 셀이어도 해당 리스트를 바라보고 있는 셀들의 값도 바뀌게 되는 것이지요. 접어두기 쪽문서 해당 내용에 익숙하지 않은 분들을 위해 상세 내용을 아래 접어두기 탭에 기록하겠습니다. 클릭해서 펼쳐주세요.(커서가 포인터 모양으로 나오지 않아요!) 가변 객체와 불변 객체, 상세내용 접기/펼치기 파이썬의 불변형 객체의 경우 변수가 참조하는 또 다른 객체를 변경할 경우 같지 않을 수 있습니다. 쉽게 표현하면 아래와 같은 상황이 나타납니다. 자세한 사항은 주석을 참조해주세요. a = 10 b = a print(a == b) # True 출력 a = 11 print(a == b) # False 출력 # a는 11, b는 10의 값으로 다르기 때문입니다. 하지만 가변형 객체의 경우 변수에 특정 객체를 참조해 할당했을 때, 참조 객체가 달라져도 같은 값을 나타냅니다. 아래와 같이 나타난다는 의미입니다. 마찬가지로 주석을 참조해주세요. a_list = [1, 2, 3] # b_list는 a_list를 참조합니다. b_list = a_list print(a_list == b_list) # True 출력 # 앗 a_list의 첫 번째 인덱스 값이 바뀌었습니다. a_list[0] = 100 # 이제 a_list는 [100, 2, 3]입니다. print(a_list == b_list) # True 출력 # 왜냐하면 a_list가 바뀌면서 b_list의 0번 인덱스 값도 바뀌었으니까요. print(b_list[0]) # 100 출력 # b_list[0]의 값도 1에서 100으로 바뀌었습니다. # b_list 역시 [100, 2, 3]입니다. 파이썬의 공식 문서의 경우 다음과 같이 설명하고 있습니다. 형은 거의 모든 측면에서 객체가 동작하는 방법에 영향을 줍니다. 객체의 아이덴티디가 갖는 중요성조차도 어떤 면에서는 영향을 받습니다: 불변형의 경우, 새 값을 만드는 연산은 실제로는 이미 존재하는 객체 중에서 같은 형과 값을 갖는 것을 돌려줄 수 있습니다. 반면에 가변 객체에서는 이런 것이 허용되지 않습니다. 예를 들어, a = 1; b = 1 후에, a 와 b 는 값 1을 갖는 같은 객체일 수도 있고, 아닐 수도 있습니다. 하지만 c = []; d = [] 후에, c 와 d 는 두 개의 서로 다르고, 독립적이고, 새로 만들어진 빈 리스트임이 보장됩니다. (c = d = [] 는 객은 객체를 c 와 d 에 대입합니다.) 출처: 파이썬 공식 문서(한국어 버전), “데이터 모델, ‘객체, 값, 형’” 따라서 각 셀을 불변형 객체가 아닌 가변형 객체로 지정합니다. 이를 통해 MERGE가 되었을 경우, 대상이 되는 셀이 변경되면 그 대상을 바라보는 셀들의 값 모두 변경될 것입니다. 3. UNMERGE 구현하기 병합되어있던 셀을 찾아 모두 해제해줍니다. 효율성을 위해 여러가지 방법이 있겠지만.. 저는 그냥 모든 칸을 순회하면서 해당 셀이 병합된 셀인지 구분해서 해제해주도록 하겠습니다. (r, c)로 지정된 셀을 ‘부모 셀’이라고 할 때, 나머지 셀들 중 어느 것이 해당 부모 셀을 따르고 있는 자식 셀인지 직접 비교하면 찾아낼 수 있겠지만, 여기서는 객체의 메모리 주소를 반환하는 파이썬의 내장 함수인 id()를 사용하겠습니다. 아래 코드를 통해 보시면 이해가 더 빠르실거에요. 참고) 파이썬 내장 함수 ‘id()’ 4. PRINT 구현하기 예쁘게 PRINT를 구현합니다. ","date":"2023-01-31","objectID":"/posts/2023/01/0131_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_05_%ED%91%9C_%EB%B3%91%ED%95%A9/:2:1","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표 병합 (Python)","uri":"/posts/2023/01/0131_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_05_%ED%91%9C_%EB%B3%91%ED%95%A9/"},{"categories":["Dev"],"content":"2. 코드 1. UPDATE 코드 최대한 직관적으로 만들어봅니다. 먼저 UPDATE는 같은 명령어임에도 두 종류가 있는데, 각 명령어는 세부 명령 코드의 개수가 다릅니다. 이를 통해 UPDATE 코드를 분기하고 문제에서 요구하는 수행을 해줍니다. # table은 표, com은 commands를 공백 기준으로 split하여 만든 리스트입니다. # com = commands_리스트_원소.split(\" \")[1:] # 따라서 com은 \"UPDATE\"와 같은 명령어 키워드를 제외한 명령값입니다. def update_cells(table, com): # 특정 값을 해당 칸에 지정하는 경우 if len(com) == 3: r, c, value = com r, c = int(r), int(c) target_cell = table[r][c] target_cell[0] = value # 특정 셀의 값을 변경하는 경우 elif len(com) == 2: v1, v2 = com for i in range(1, len(table)): for j in range(1, len(table[0])): if table[i][j][0] == v1: table[i][j][0] = v2 else: raise RuntimeError(\"UPDATE 매개변수 개수가 잘못 되었습니다.\") 2. MERGE 코드 위의 내용대로 코드를 구현해보겠습니다. def merge_cells(table, com): r1, c1, r2, c2 = map(int, com) # 두 셀이 같은 칸이면 아무 것도 하지 않는다는 문제 조건 if r1 == r2 and c1 == c2: return # 각 셀을 변수로 지정 # 각 칸들은 [\"rice\"] 혹은 [\"korean\"]처럼 리스트로 이루어져 있습니다. cell1 = table[r1][c1] cell2 = table[r2][c2] # 각 셀은 리스트이므로, [0]으로 지정해줘야 해당 값이 지정됩니다. # 따라서 각 값들은 \"rice\", \"korean\"과 같은 실제 값이 됩니다. v1 = cell1[0] v2 = cell2[0] # 위에서 이야기한 네 번째 경우의 수에만 value2를 value1으로 지정할 수 있습니다. # parent_cell은 값을 전달하는 셀, child_cell은 부모의 값을 부여받는 셀입니다. # 자식 칸의 아이디로 대상이 될 자식들을 찾읍시다. if v2 and not v1: child_id = id(cell1) parent_cell = cell2 else: child_id = id(cell2) parent_cell = cell1 for i in range(1, len(table)): for j in range(1, len(table[0])): # 자식 칸이면 부모 칸을 바라볼 수 있도록 할당합니다. if id(table[i][j]) == child_id: table[i][j] = parent_cell 3. UNMERGE 코드 자식이 되는 셀 찾기, 그리고 그 칸에 새로운 주소값을 가진 새 리스트를 부여합니다. def unmerge_cells(table, com): r, c = map(int, com) value = table[r][c][0] # (r, c)칸과 같은 id 값을 가진 칸 = 병합된 칸을 찾기 위한 id target_cell_id = id(table[r][c]) for i in range(1, len(table)): for j in range(1, len(table[0])): cell_id = id(table[i][j]) # id가 같은 칸, 즉 병합된 칸이라면 if cell_id == target_cell_id: # 새로운 리스트 부여 table[i][j] = [None] # 기존에 값이 존재했다면 if value: # 원래 칸에 그 값을 넣어줍니다. table[r][c][0] = value 문제 해결 코드 이와 같이 완성된 코드들을 합치면 다음과 같은 모습이 됩니다. # table은 표, com은 commands를 공백 기준으로 split하여 만든 리스트입니다. # com = commands_리스트_원소.split(\" \")[1:] # 따라서 com은 \"UPDATE\"와 같은 명령어 키워드를 제외한 명령 정보를 담은 값입니다. def update_cells(table, com): # 특정 값을 해당 칸에 지정하는 경우 if len(com) == 3: r, c, value = com r, c = int(r), int(c) target_cell = table[r][c] target_cell[0] = value # 특정 셀의 값을 변경하는 경우 elif len(com) == 2: v1, v2 = com for i in range(1, len(table)): for j in range(1, len(table[0])): if table[i][j][0] == v1: table[i][j][0] = v2 else: raise RuntimeError(\"UPDATE 매개변수 개수가 잘못 되었습니다.\") def merge_cells(table, com): r1, c1, r2, c2 = map(int, com) # 두 셀이 같은 칸이면 아무 것도 하지 않는다는 문제 조건 if r1 == r2 and c1 == c2: return # 각 셀을 변수로 지정 # 각 칸들은 [\"rice\"] 혹은 [\"korean\"]처럼 리스트로 이루어져 있습니다. cell1 = table[r1][c1] cell2 = table[r2][c2] # 각 셀은 리스트이므로, [0]으로 지정해줘야 해당 값이 지정됩니다. # 따라서 각 값들은 \"rice\", \"korean\"과 같은 실제 값이 됩니다. v1 = cell1[0] v2 = cell2[0] # 위에서 이야기한 네 번째 경우의 수에만 value2를 value1으로 지정할 수 있습니다. # parent_cell은 값을 전달하는 셀, child_cell은 부모의 값을 부여받는 셀입니다. # 자식 칸의 아이디로 대상이 될 자식들을 찾읍시다. if v2 and not v1: child_id = id(cell1) parent_cell = cell2 else: child_id = id(cell2) parent_cell = cell1 for i in range(1, len(table)): for j in range(1, len(table[0])): # 자식 칸이면 부모 칸을 바라볼 수 있도록 할당합니다. if id(table[i][j]) == child_id: table[i][j] = parent_cell def unmerge_cells(table, com): r, c = map(int, com) value = table[r][c][0] # (r, c)칸과 같은 id 값을 가진 칸 = 병합된 칸을 찾기 위한 id target_cell_id = id(table[r][c]) for i in range(1, len(table)): for j in range(1, len(table[0])): cell_id = id(table[i][j]) # id가 같은 칸, 즉 병합된 칸이라면 if cell_id == target_cell_id: # 새로운 리스트 부여 table[i][j] = [None] # 기존에 값이 존재했다면 if value: # 원래 칸에 그 값을 넣어줍니다. table[r][c][0] = value # 값이 있는 칸은 잘 출력해줍니다. # 없으면 'EMPTY'를 출력합니다. def print_cells(table, com): r, c = map(int, com) # table[r][c][0]에 값이 있으면 해당 값을, 아니면 \"EMPTY\"를 반환합니다. return table[r][c][0] or 'EMPTY' # 명령어에 따라 실행 명령 종류를 정해주는 함수 def commit_commands(com_tokens_list, table, answer = []): command = com_tokens_list[0] com = com_tokens_list[1:] if command == \"UPDATE\": update_cells(table, com) elif command == \"MERGE\": merge_cel","date":"2023-01-31","objectID":"/posts/2023/01/0131_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_05_%ED%91%9C_%EB%B3%91%ED%95%A9/:2:2","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표 병합 (Python)","uri":"/posts/2023/01/0131_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_05_%ED%91%9C_%EB%B3%91%ED%95%A9/"},{"categories":["Dev"],"content":"표현 가능한 이진트리 문제를 풀어보려고 합니다. 프로그래머스의 2023 KAKAO BLIND RECRUITMENT 문제팩 필터를 통해 찾아볼 수 있으며, 🚀여기를 클릭하면 바로 이동할 수 있습니다. 제 코드는 가장 이상적인 해법이 아닙니다. 다만 저의 생각과 코드 작성의 방식을 공유하고자 글을 작성해봅니다.😋 ","date":"2023-01-25","objectID":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/:0:0","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표현 가능한 이진트리 (Python)","uri":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"categories":["Dev"],"content":"문제 🚀표현 가능한 이진트리 참고 링크 | 프로그래머스의 문제를 외부에 게시할 수 있나요? ","date":"2023-01-25","objectID":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/:1:0","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표현 가능한 이진트리 (Python)","uri":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"categories":["Dev"],"content":"풀이 ","date":"2023-01-25","objectID":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/:2:0","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표현 가능한 이진트리 (Python)","uri":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"categories":["Dev"],"content":"1. 해결 아이디어 탐색: 변환된 십진수는 어떻게 표현될까? 포화 이진트리는 각 높이에 모든 노드들이 빼곡히 들어선 피라미드 모양의 이진트리입니다. 문제에서는 이진수로 표현된 이진트리의 경우, 비어있는 노드는 0으로, 실제 존재하는 노드는 1로 표기하고 있음을 밝히고 있습니다. 문제에서 주어진 numbers 배열의 숫자의 경우 이진수로 변환했을 때, 앞 자리에 얼마 만큼의 0이 존재하는지 알 수 없습니다. 문제에서 예시로 든 42를 예로 들어볼까요? 42를 이진수로 표현하면 101010입니다. 해당 수는 이진트리로 표현할 수 있다는 것을 문제에서 알려주고 있고 그 형태는 다음과 같습니다. 111의 트리 노드의 형태를 보고 직관적으로 이진수로 표현하면 111로 나타나는 트리입니다. 10진수로 나타내면 7에 해당하는 트리네요. 다시 42, 이진수 101010으로 돌아와 생각해 보겠습니다. 42는 이진트리로 나타낼 경우에 0101010이며 그림으로 나타나면 다음과 같이 나타낼 수 있습니다. 손으로 그렸는데 깔끔하지 않게 됐어요. 그래서 귀엽기라도 해보자했습니다. 나쁘지 않네요. 낫 밷. 회색 웃는 점들이 비어있는 노드들입니다. 그림처럼 비어있는 노드를 추가하니 111로만 표현될 것만 같았던 트리가 다른 방식으로도 표현됐습니다. 지금은 0101010이네요. 네, 우리에게 익숙한 10진수로는 42입니다. 우주의 진리인 수인 만큼 트리 모양도 아름답네요. 여기에 빈 노드들로만 이루어진 한 층을 추가해도 트리가 만들 수 있지 않을까요? 자유민주주의 대한민국에서 안될 것 없죠. 해보죠, 까짓 거. 이렇게 만들어진 트리는 000100010001000으로 나타낼 수 있습니다. 십진수로는 2184에 해당하는 숫자입니다. 이를 통해 우리가 알 수 있는 것은, 같은 모양의 트리도 다른 수를 나타낼 수 있다는 것입니다. 여기서 하나의 의문이 생기는데요, ‘’그렇다면 이진수로 변환된 수의 앞에 몇 개의 0을 붙여야 비어있는 노드가 포함된 트리 표현수가 될까?‘입니다. 발견: 포화 이진 트리로 표현하기 위의 시행에서 알아낸 사실이 있습니다. 이진수로 표현된 해당 십진수를 트리로 그리게 되면 그 형태는 포화 이진 트리로 만들어진다는 사실이죠. 해당 형태의 포화 이진 트리를 만들고, 비어있는 자식 노드를 0으로 바꾸게 되면 해당 숫자를 알아낼 수 있습니다. 달리 생각하면, 포화 이진트리를 통해 비어있는 노드가 포함된 트리를 구성할 수 있고, 이진수에서 가장 앞자리에 등장하는 1 앞에 등장하는 0의 개수도 알 수 있다는 의미이죠. 다음의 이진 트리는 1111111입니다. 42의 이진트리 표현 수인 0101010에서 비어있던 모든 노드를 채워놓은 형태로 볼 수 있겠네요. 42는 101010으로 바꾸어지며 여섯 자리의 2진수로 나타나게 된다는 것을 알 수 있습니다. 3층 짜리 이진 포화트리에서 뭔가가 부족한 트리라는 것을 우리는 확인할 수 있었죠. 이와 같이 십진수의 해당 숫자를 2진수로 바꾸면 지금 몇 개의 노드로 이루어진 트리인지 알 수 있게 되고, 해당 노드 개수보다 큰 포화이진트리 중에 가장 가까운 포화이진트리가 목표 숫자의 형태로 만들 수 있는 포화 이진 트리임을 알 수 있습니다. 그럼 가장 가까운 포화 이진 트리는 어떻게 알 수 있을까요? 그건 지금까지 직접 그려본 결과 노드의 숫자를 보면 알 수 있었죠. 그리고 포화 이진 트리는 높이 h에 대해 2^(h + 1) - 1개의 노드 개수를 가집니다. 2층 짜리 포화 이진 트리는 3개, 3층 짜리 포화 이진 트리는 7개, … 5층 짜리 이진트리는 63개의 노드 개수를 가지게 될 것입니다. 포화 정 이진 트리에서, 다. 따라서, 이다. (l은 리프 노드의 개수를 의미한다.) 출처: 위키피디아, “이진 트리” 지금까지 예를 들었던 42로 다시 이 과정을 정리하면 42로 이진트리를 만들 수 있을까? -\u003e 이진수로 변환해보자 -\u003e 101010이란 값을 얻었다! -\u003e 현재 노드의 개수는 6개, 1앞에 필요한 0의 개수? -\u003e 가장 가까운 포화 이진 트리의 노드 개수를 통해 알 수 있었지 -\u003e 42의 노드 개수 6은 3(= 2^2 - 1)보다는 크지만 7(= 2^3 - 1) 보다는 작다! -\u003e 즉 7개 노드로 이루어진 포화 이진 트리 1111111이 42가 그려질 트리의 형태이고 노드 한 개가 부족하니까 42는 0101010으로 나타낼 수 있다! 다음과 같은 과정을 통해 0까지 포함된, 즉 비어있는 노드까지 포함된 42가 나타낼 이진 트리의 형태를 알아낼 수 있습니다. 통합: 가공한 자료를 통해 문제 해결하기 자 이제 십진수를 0까지 포함된 트리 표현식으로 해결할 수 있으니, 문제를 해결할 수 있습니다. 이제 주어진 이진 표현식으로 판별만 하면 되는데, 해당 트리 표현수가 실제 유효한 트리인 것은 어떻게 알 수 있을까요? 간단합니다. 예시에서 나타났듯, 자식 노드가 부모 노드가 존재할 때 존재하면 됩니다. 그림으로 나타내면 간단한 이야기입니다. 가령 5, 이진수로 나타냈을 때 101은 이진 트리로 나타낼 수 없습니다. 트리가 가내수공업이라 좀 찌그러졌는데 이해해주세요.😘 다음과 같이 부모는 없지만 자식이 있는 형태이기 때문입니다. 부모 없는 자식이 있을 수 없죠. 뭔가 패륜적 언사 같은데 오해하지 말고 들어주세요. 트리는 부모가 있어야 자식이 존재할 수 있습니다. 따라서 부모 노드 없는 자식노드로 이루어진 트리란 존재할 수 없습니다. 101로 나타내는 트리 형태는 부모 없이 자식들로만 이루어진 트리이기 때문에 존재할 수 없습니다. 자 그럼 이런 형태인지 아닌지만 판별해주면 되겠네요. 어떻게 하면 될까요? 바로 이 작업을 해주기 위해 0이 표시된 정 이진 트리로 만들기 위해 애썼던 것이죠. 다시 42를 가져와서 설명을 하자면, 현재 트리의 최상단 노드, 즉 루트 노드는 트리 표현수의 가장 중앙에 위치하는 수입니다. 0101010에서 루트노드는 네 번째 1입니다. 0101010에서의 까맣게 칠해진 1이죠. 이와 같은 작업을 반복해줍니다. 0101010에서 가장 루트 노드 1(0101010)은 부모와 자식이 이루어지는 = 자식이 있으며 부모가 존재하는 노드입니다. 그림에서 보여주는 빨간색 부분이 트리가 가능함을 확인했고, 그 아래 존재하는 노란 자식들이 부모가 존재하는, 존재할 수 있는 트리임을 확인했습니다. 이것을 반복해줍니다. 이제 010 [1] 010으로 쪼개어, 자식 트리들도 트리로 만들어지는 봅니다. 010 [1] 010에서 [1] 왼쪽의 010은 아래 그림의 A트리가 될 것이고, 오른쪽 010은 B 트리가 될 것입니다. 공교롭게도 두 자식 트리 모두 010이네요. 부모가 존재하고 자식이 비어있는 구조입니다. 자식은 비어있어도 상관없습니다. 부모가 있다면 말이지요. 하지만 반대로 부모가 존재하지 않는데, 자식이 존재하면 안됩니다. 101(=십진수 5)와 같은 형태가 있으면 안되죠. 따라서 순차적으로 해당 이진트리를 표현하는 수의 중앙이 1이며, 자식 트리를 분리한 뒤 자식 트리를 다시 부모노드가 존재하는 트리인지 판별하는 과정을 반복해주면 됩니다. 또, 부모노드가 존재하지 않는데 자식 노드가 존재하는지 확인을 해주면 되겠습니다. 리프 노드에 닿을 때까지요. 전형적인 분할정복 방식의 코드가 될 것 같네요. ","date":"2023-01-25","objectID":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/:2:1","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표현 가능한 이진트리 (Python)","uri":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"categories":["Dev"],"content":"2. 코드 1. 십진수를 이진수로 변환하기 위에서 이야기한대로 코드를 짜보겠습니다. 다음 함수는 십진수를 비어있는 0까지 모두 표현된 이진수(: sting)를 반환할 것입니다. # 현재 수 이진 값으로 만들기 def conv_to_bintree(num): # 이진 값으로 변환된 수 target_num = bin(num)[2:] # 노드개수 node_cnt = len(target_num) # 가장 가까운 포화 이진 트리 찾기 # 다음은 2의 지수가 될 변수 # 'exp' stands for exponential exp = 0 # (2의 제곱수 - 1)는 이진트리로 변환 했을 때 포화 이진 트리가 된다. # 가령 (2**2 - 1 = 3)의 경우 2층 포화 이진 트리, (2**3 - 1 = 7)의 경우 3층 포화 이진 트리가 된다. # 그러므로 현재 값보다 큰 가장 가까운 2의 제곱수로 만든 이진트리가 자식 노드가 몇 개 비워진 이진트리가 된다. while True: # 현재 값을 넘는 가장 가까운 2의 제곱 수인 경우 if node_cnt \u003c 2 ** exp: # 비어진 말단 최하단이자 최좌단의 노드 경우 0을 채워준다. # .zfill()의 자세한 설명은 아래 링크에 return target_num.zfill(2 ** exp - 1) # 목표가 되는 수가 2**지수 보다 작을 경우 지수를 하나 더해줌 else: exp += 1 참고) 자릿수에 맞게 string에 0 채우는 메소드; str.zfill() 2. 이진트리 표현수가 유효한 트리 표현 방식인지 판별 이제 이진수로 표현된 수를 가지고 유효한 트리로 만들어지는 확인해봅시다. def verdict(target_num): stack = [target_num] while stack: num = stack.pop() # 현재 노드의 길이가 2보다 작으면 리프 노드 if len(num) \u003c= 2: continue # 현재 이진수로 표현된 트리의 가운데 값이 최상단 부모 노드 parent_node = len(num) // 2 # 부모노드가 0인데 자식노드가 존재하는 경우 -\u003e 트리로 표현되지 않는 표현식 # 따라서 이진 트리로 만들 수 없다고 판별하여 0을 반환 if (num[parent_node]) == '0' and '1' in num: return 0 # 현재 이진트리를 반으로 쪼개서 왼쪽 트리를 스택에 넣기 stack.append(num[:parent_node]) # 오른쪽 트리를 스택에 넣기 stack.append(num[parent_node + 1:]) # 순회가 끝난 경우 완성할 수 있는 트리이므로 1을 반환 return 1 다음의 큰 두 가지 아이디어로 해결할 수 있는 문제였습니다. 전체 코드를 구성하면 다음과 같습니다. 문제 해결 코드 # 현재 수 이진 값으로 만들기 def conv_to_bintree(num): # 이진 값으로 변환된 수 target_num = bin(num)[2:] # 노드개수 node_cnt = len(target_num) # 가장 가까운 포화 이진 트리 찾기 # 다음은 2의 지수가 될 변수 # 'exp' stands for exponential exp = 0 # (2의 제곱수 - 1)는 이진트리로 변환 했을 때 포화 이진 트리가 된다. # 가령 (2**2 - 1 = 3)의 경우 2층 포화 이진 트리, (2**3 - 1 = 7)의 경우 3층 포화 이진 트리가 된다. # 그러므로 현재 값보다 큰 가장 가까운 2의 제곱수로 만든 이진트리가 자식 노드가 몇 개 비워진 이진트리가 된다. while True: # 현재 값을 넘는 가장 가까운 2의 제곱 수인 경우 if node_cnt \u003c 2 ** exp: # 비어진 말단 최하단이자 최좌단의 노드 경우 0을 채워준다. return target_num.zfill(2 ** exp - 1) # 목표가 되는 수가 2**지수 보다 작을 경우 지수를 하나 더해줌 else: exp += 1 def verdict(target_num): stack = [target_num] while stack: num = stack.pop() # 현재 노드의 길이가 2보다 작으면 리프 노드 if len(num) \u003c= 2: continue # 현재 이진수로 표현된 트리의 가운데 값이 최상단 부모 노드 parent_node = len(num) // 2 # 부모노드가 0인데 자식노드가 존재하는 경우 -\u003e 트리로 표현되지 않는 표현식 # 따라서 이진 트리로 만들 수 없다고 판별하여 0을 반환 if (num[parent_node]) == '0' and '1' in num: return 0 # 현재 이진트리를 반으로 쪼개서 왼쪽 트리를 스택에 넣기 stack.append(num[:parent_node]) # 오른쪽 트리를 스택에 넣기 stack.append(num[parent_node + 1:]) # 순회가 끝난 경우 완성할 수 있는 트리이므로 1을 반환 return 1 def solution(numbers): answer = [] # 현재 숫자들의 이진 값들이 담길 리스트 bin_nums = [] for num in numbers: # 현재 수를 이진수로 변환하기 bin_nums.append(conv_to_bintree(num)) for bin_num in bin_nums: # 변환된 수를 이진트리로 만들 수 있는지 확인하기 answer.append(verdict(bin_num)) return answer ‘이렇게하면 이렇게 되나…?’’ 하고, 손으로 그려가며 풀어본 문제였습니다. 복잡할 것 같은 문제도 코드로 적어내면 막상 길지 않은 경우가 있는데, 이 문제도 그런 경우였네요. 이번 문제는 이렇게 마무리하고 다음에는 제가 2023 KAKAO BLIND RECRUITMENT에서 풀면서 가장 재밌었던 표 병합의 해결 방법을 기록해보겠습니다. ","date":"2023-01-25","objectID":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/:2:2","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 표현 가능한 이진트리 (Python)","uri":"/posts/2023/01/0125_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_04_%ED%91%9C%ED%98%84_%EA%B0%80%EB%8A%A5%ED%95%9C_%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"categories":["Dev"],"content":"첫 번째 문제에 이어 다음으로 이모티콘 할인행사 문제 코드를 올려보려고 합니다. 프로그래머스의 2023 KAKAO BLIND RECRUITMENT 문제팩 필터를 통해 찾아볼 수 있으며, 🚀여기를 클릭하면 바로 이동할 수 있습니다. 제 코드는 가장 이상적인 해법이 아닙니다. 다만 저의 생각과 코드 작성의 방식을 공유하고자 글을 작성해봅니다.😋 ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/:0:0","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 이모티콘 할인행사 (Python)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/"},{"categories":["Dev"],"content":"문제 🚀이모티콘 할인행사 참고 링크 | 프로그래머스의 문제를 외부에 게시할 수 있나요? ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/:1:0","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 이모티콘 할인행사 (Python)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/"},{"categories":["Dev"],"content":"풀이 ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/:2:0","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 이모티콘 할인행사 (Python)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/"},{"categories":["Dev"],"content":"1. 해결 아이디어 문제 해결 방법을 고민해보기 예전에는 코딩 테스트 문제를 풀 때 그리디 하게 문제 해결이 가능한가?를 먼저 생각했습니다. 그런데 그렇게 접근하는 것보다는 완전탐색이 가능한가?를 먼저 접근했을 때 더 빨리 문제 해결을 할 수 있었습니다. 탐색 시간을 생각해보고 안되겠다 싶으면 그리디한 문제 해결법을 찾는 순서로 문제를 해결하는 게 더 효율적일 때가 많더라고요. 엄격하게 속도를 파악했을 때, 순수 파이썬은 1초에 1000만 루프의 일을 처리할 수 있다고 합니다. 1초(=1,000ms)의 해결 시간이 주어지는 문제라면 1000만번 미만의 시행 횟수의 경우 통과할 수 있겠다고 예측하며 문제에 접근할 수 있겠습니다. 참고 파이썬의 처리 속도에 대한 아티클: How Slow is Python Compared to C. (2020.07.13 작성) 시행횟수 짐작해보기 완전 탐색으로 문제를 해결한다고 할 경우 문제의 핵심이 되는 경우의 수는 이모티콘 할인의 가짓 수입니다. 문제에 의하면 이모티콘은 반드시 할인 가격으로 판매되는데 할인율의 경우 [10%, 20%, 30%, 40%]의 총 네 가지입니다. 그리고 고객들은 판매되는 가격 기준으로 이모티콘을 구매할지, 이모티콘 플러스를 구독할지 결정합니다. 고객의 수를 n으로, 이모티콘의 개수를 m이라고 할 경우 경우의 수는 4^m * n 입니다. 그런데 문제 제한 사항을 보면 이모티콘 개수는 최대 7개입니다. m의 값만 고려할 때, 4의 7 제곱의 경우 16,384번의 시행을 하게 되는 것이고 고객의 최대 수 값 100을 고려해도 1,638,400번의 시행횟수이므로 충분히 해볼만한 가짓수로 볼 수 있겠네요. 그래서 모든 이모티콘의 할인 경우의 수를 통해 문제를 해결해볼만 하다고 보고 모든 가짓수를 탐색하는 식으로 문제를 해결해보겠습니다. 모든 할인의 수를 어떻게 표현할 것인가? 모든 경우의 수를 찾는 것이므로 중복조합의 경우의 수를 고려하는 문제입니다. 여러 구현 방법이 있지만, 저는 재귀함수를 사용하는 편이 제일 편리하더라고요. 여기서는 먼저 재귀함수로 중복 조합을 표현하겠습니다. 그리고 파이썬에서는 itertools 모듈의 product가 자체적으로 중복조합을 제공합니다. 갓이썬… 그저 빛…⭐️ ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/:2:1","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 이모티콘 할인행사 (Python)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/"},{"categories":["Dev"],"content":"2. 코드 1. 중복조합 코드 짜기 할인율은 10/20/30/40의 총 네 가지 값을 가집니다. 이모티콘이 하나일 경우 해당 할인율이 적용되는 네 가지의 경우가, 두 가지일 경우 4 * 4의 16가지 경우의 수가 만들어지겠죠. 두 이모티콘 모두 10% 할인으로 경우의 수를 늘려간다고 한다면 (10, 10), (10, 20), (10, 30), (10, 40), (20, 10), (20, 20) … (40, 20), (40, 30), (40, 40) 위와 같은 모든 할인 경우의 수를 살펴볼 것입니다. 재귀로 함수를 구현한다면 다음과 같은 코드가 될 것입니다. def 재귀함수(현재_인덱스 = 0, 현재_할인율_정보 = [0] * 이모티콘_개수): nonlocal 전체_할인률이_담기는_리스트 # 현재 인덱스를 0부터 이모티콘 개수까지 이동할텐데, 현재 인덱스가 이모티콘 개수와 같다면 모든 경우의 수를 변경해준 결과일 것입니다. if 현재_인덱스 == 이모티콘_개수: return 현재_할인율_정보 # 모든 할인율에 대해 # dc_rate는 [10, 20, 30, 40]을 넣은 값입니다. for 할인율 in dc_rate: 현재_할인율_정보[현재_인덱스] = 할인율 # 10, 20, 30, 40 중 하나를 넣어줍니다. # 다음 인덱스로 이동해줍니다. 재귀함수(현재_인덱스 + 1, 현재_할인율_정보) # 할인율 정보 리스트도 같이 넣어주죠. 중복 조합이기 때문에 그리 복잡하지 않은 재귀 함수가 완성됩니다. 해당 코드로 문제를 해결하는 코드를 완성하면 다음과 같습니다. solution() 함수 내부에 필요한 함수들을 넣었습니다. def solution(users, emoticons): # 문제에서 주어진 할인율 조건 네 가지 dc_rate = [10, 20, 30, 40] # 수많은 할인율의 경우의 수가 구현될 리스트의 초기 정보 temp_arr = [0] * len(emoticons) # 주어진 할인율에 따라 계산하는 함수 def cal(dc_info): # 구독자 수 sub_cnt = 0 # 구독하지 않을 경우 이모티콘에 지불한 금액 profit = 0 # 각 사용자에 대해 할인율 경우의 수를 적용해 연산해 봄 for user in users: # 사용자 정보는 (구매할 할인율 기준, 자산)으로 구성됨 dc_cut, budget = user # 이모티콘을 구매할 경우, 할인율이 적용된 이모티콘에 지불한 총액 sum_cost = 0 # 현재 사용자를 기준, 모든 이모티콘 금액을 순회 for idx, emo in enumerate(emoticons): # 현재 고객의 할인 등급율보다 현재 할인율이 더 높다면 # 즉 구매 대상인 이모티콘이라면 if dc_cut \u003c= dc_info[idx]: # 누적 지출에 현재 할인된 이모티콘 구매 가격을 더해준다. sum_cost += emo - int(emo * (dc_info[idx] / 100)) # 누적 지출 금액이 자산 이상이 된다면 # 즉 구매를 포기하고 구독을 원하게 된다면 if sum_cost \u003e= budget: # 구독자 수를 하나 더해준다. sub_cnt += 1 break # 만약 무사히 순회가 종료됐다면 # 구독하지 않고 이모티콘을 구매하는 것이므로 # 지금 고객의 지출 금액을 전체 수익에 더해준다. else: profit += sum_cost return [sub_cnt, profit] # 결과 = [구독자 수, 이모티콘 판매 이윤] result = [0, 0] # 이모티콘의 모든 할인율을 만드는 중복조합 만들기 def recur_sale(my_idx = 0, my_arr = temp_arr): nonlocal result # 현재 할인율이 완성되었다! if my_idx == len(emoticons): # 현재 할인율 정보(my_arr)로 이윤과 구독자 수를 구해보자! crnt_result = cal(my_arr) # 만약 현재 시행까지의 최대 구독자 수보다 지금 시행의 구독자 수가 더 많다면 if crnt_result[0] \u003e result[0]: # 지금 시행이 정답에 가깝다. result = crnt_result[:] # 구독자 수는 같은데, 이윤이 더 많다면 elif crnt_result[0] == result[0]: if crnt_result[1] \u003e result[1]: # 정답의 조건에 맞는다. result = crnt_result[:] return # 위의 코드와 마찬가지로 중복조합 만들어주기 for dc in dc_rate: my_arr[my_idx] = dc recur_sale(my_idx + 1, my_arr) # 실제 시행 recur_sale() return result 2. product 사용하기 파이썬의 product를 사용한다면 더 간편하게 문제를 해결할 수 있습니다. for 루프를 통해 product를 사용하는 방법은 다음과 같습니다. 수를 세는 경우의 값을 넣어주고, 해당 값이 총 몇 번 반복이 되는지는 repeat 옵션을 통해 넣어줍니다. 가령 [10, 20, 30, 40]의 가지 수가 모두 3가지 경우가 하나 씩 값을 가질 때 product([10, 20, 30, 40], repeat=3 으로 표현해줍니다. product 관련 코드는 51번째 줄부터입니다. from itertools import product def solution(users, emoticons): # 문제에서 주어진 할인율 조건 네 가지 dc_rate = [10, 20, 30, 40] # 수많은 할인율의 경우의 수가 구현될 리스트의 초기 정보 temp_arr = [0] * len(emoticons) # 주어진 할인율에 따라 계산하는 함수 def cal(dc_info): # 구독자 수 sub_cnt = 0 # 구독하지 않을 경우 이모티콘에 지불한 금액 profit = 0 # 각 사용자에 대해 할인율 경우의 수를 적용해 연산해 봄 for user in users: # 사용자 정보는 (구매할 할인율 기준, 자산)으로 구성됨 dc_cut, budget = user # 이모티콘을 구매할 경우, 할인율이 적용된 이모티콘에 지불한 총액 sum_cost = 0 # 현재 사용자를 기준, 모든 이모티콘 금액을 순회 for idx, emo in enumerate(emoticons): # 현재 고객의 할인 등급율보다 현재 할인율이 더 높다면 # 즉 구매 대상인 이모티콘이라면 if dc_cut \u003c= dc_info[idx]: # 누적 지출에 현재 할인된 이모티콘 구매 가격을 더해준다. sum_cost += emo - int(emo * (dc_info[idx] / 100)) # 누적 지출 금액이 자산 이상이 된다면 # 즉 구매를 포기하고 구독을 원하게 된다면 if sum_cost \u003e= budget: # 구독자 수를 하나 더해준다. sub_cnt += 1 break # 만약 무사히 순회가 종료됐다면 # 구독하지 않고 이모티콘을 구매하는 것이므로 # 지금 고객의 지출 금액을 전체 수익에 더해준다. else: profit += sum_cost return [sub_cnt, profit] # 결과 = [구독자 수, 이모티콘 판매 이윤] result = [0, 0] # 아래와 같이 간단히 중복조합을 사용할 수 있습니다. for info in product(dc_rate, repeat=len(emoticons)): cnrt_result = cal(info) sub_cnt, profit = cnrt_result # 아래부터는 result를 판별하는 코드입니다. if sub_cnt \u003e result[0]: result = cnrt_result elif sub_cnt == result[0]: if profit \u003e result[1]: result = cnrt_result return result ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/:2:2","tags":["Python","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 이모티콘 할인행사 (Python)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_03_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/"},{"categories":["Dev"],"content":"카카오의 2023년 블라인드 공개채용의 코딩테스트 문제가 공개되었습니다. 프로그래머스의 2023 KAKAO BLIND RECRUITMENT 문제팩 필터를 통해 찾아볼 수 있습니다. 🚀여기를 클릭하면 바로 이동할 수 있습니다. 공개된 문제 중 몇 가지 문제를 풀어 코드를 올려보려고 합니다. 제 코드는 가장 이상적인 해법이 아닙니다. 다만 저의 생각과 코드 작성의 방식을 공유하고자 글을 작성해봅니다.😋 ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/:0:0","tags":["JavaScript","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 개인정보 수집 유효기간 (JavaScript)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/"},{"categories":["Dev"],"content":"문제 🚀개인정보 수집 유효기간 참고 링크 | 프로그래머스의 문제를 외부에 게시할 수 있나요? ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/:1:0","tags":["JavaScript","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 개인정보 수집 유효기간 (JavaScript)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/"},{"categories":["Dev"],"content":"풀이 1번 문제로 자주 나오는 데이터 변환 문제입니다. 몇 가지 주의사항만 주의해주면 어려움 없이 해결할 수 있는 문제입니다. ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/:2:0","tags":["JavaScript","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 개인정보 수집 유효기간 (JavaScript)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/"},{"categories":["Dev"],"content":"1. 해결 아이디어 날짜 환산해주기 일자를 오늘 기준으로 유효한지 파악하는 문제입니다. 먼저 기준 일자 단위를 정합니다. 시간의 최소단위가 일자이므로 일 기준으로 각 날짜들을 환산해줍니다. 단 제한사항으로 가장 이른 시작 연도는 2000년이며, 각 월은 28일입니다. 따라서 연도는 2001년을 1, 2010년을 10 등의 단위 연도로 바꿔주기 위해 주어진 연도에 2000을 빼줍니다. 또한, 각 개월은 28일을 곱해서 일 수를 구해줍니다. 따라서 구하게 될 변환 날짜는 다음과 같습니다. 환산 일자 = ((기준 연도 - 2000) * 12개월 * 28일) + 개월 * 28 + 일 정책 정리하기 각 정책들은 개월 수로 표현됩니다. 또한 정책의 이름은 스트링인 알파벳으로 주어집니다. 따라서 정책 이름을 키 값으로, 유효 개월 수를 밸류로 하는 객체로 접근하면 데이터 접근이 편할 것 같네요. 기타 유의사항 정책 유효 기한은 만으로 1년입니다. 따라서 기준 일자의 일자에서 하나 부족한 날까지 유효합니다. 가령 유효 기간이 12개월이고 보관 시작일이 2021년 1월 5일이라면 2022년 1월 4일까지가 유효한 기간입니다. 이는 친절하게 문제해서도 알려주고 있네요. ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/:2:1","tags":["JavaScript","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 개인정보 수집 유효기간 (JavaScript)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/"},{"categories":["Dev"],"content":"2. 코드 따라서 코드를 작성하면 다음과 같습니다. // 연월일을 전달 받으면 이를 환산된 일자로 변환하는 함수 const convertDate = (date) =\u003e { const dateInfo = date.split(\".\").map(elm =\u003e Number(elm)); return (dateInfo[0] - 2000) * 12 * 28 + dateInfo[1] * 28 + dateInfo[2]; } const solution = (today, terms, privacies) =\u003e { const result = []; // 변환된 오늘 날짜 const _today = convertDate(today); // 정책 이름 - 개월 수를 key-value로 하는 객체 policyInfo = {}; terms.map(term =\u003e { const [policyName, month] = term.split(\" \"); /** month 값은 스트링이므로 Number로 변환해줍시다. * 여러 변환 방법이 있지만, * JavaScript 작성의 컨벤션으로 많이 사용되는 AirBnb의 숫자 변환은 Number()를 사용해주는 것입니다. * 여기서도 그렇게 해주도록 할게요. */ policyInfo[policyName] = Number(month) }) privacies.map((infos, idx) =\u003e { const [dateInfo, policy] = infos.split(\" \"); // 유효 완료 일자를 환산해준 값. 만으로 개월 수가 유효하기 때문에 1을 빼줍니다. const dateConverted = convertDate(dateInfo) + policyInfo[policy] * 28 - 1; // 만약 오늘이 유효 일자를 넘었다면 파기해야 할 정보이므로 결과에 넣어줍니다. if (_today \u003e dateConverted) { // 인덱스가 1부터 시작하니까 잊지 말고 1 더해주기. result.push(idx + 1); } }) return result; } ","date":"2023-01-14","objectID":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/:2:2","tags":["JavaScript","Algorithm","Coding Test","Kakao"],"title":"[카카오 블라인드 채용 코딩테스트 2023] 개인정보 수집 유효기간 (JavaScript)","uri":"/posts/2023/01/0114_%EC%B9%B4%EC%B9%B4%EC%98%A4_%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C_2023_01_%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4_%EC%88%98%EC%A7%91_%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84/"},{"categories":["Dev"],"content":"온라인 강의 사이트 udemy에서 React 완벽 가이드 with Redux, Next.js, TypeScript를 요즘 수강 중인데, 해당 강의에서 나온 내용을 기반으로 몇 가지 정리해보고자 합니다. 간단한 예시 화면을 만들어 보겠습니다. 멋진 팬톤의 Baby Blue를 배경색으로, Classic Blue를 버튼 색상으로 사용했습니다. 버튼이 있고 버튼을 누르면 텍스트 색상을 바꾸도록 해볼까요. 변했을 때 색상은 마찬가지로 팬톤 색상의 Rococco Red로 바꾸어 보겠습니다. ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:0:0","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"1. 인라인에서 직접 스타일 하기 (Inline Style) JSX 코드의 style을 직접 변경하는 경우입니다. isSwitched 라는 값을 Boolean 값으로 설정해서, 버튼을 눌렀을 때마다 false/true를 변환해주도록 했습니다. inline에서 스타일을 직접 지정할 경우 이중괄호를 사용합니다. 바깥 중괄호는 JSX 내 자바스크립트 코드를 사용하기 위한 중괄호이며, 내부 중괄호는 객체 리터럴을 사용하기 위한 중괄호입니다. 전체 코드는 다음과 같습니다. // src/components/StylePrac.js import React, { useState } from \"react\"; import \"./StylePrac.css\"; const StylePrac = () =\u003e { const [isSwitched, setIsSwitced] = useState(false); const switchHandler = () =\u003e { setIsSwitced(!isSwitched); }; return ( \u003cdiv\u003e \u003ch1 style={{ color: isSwitched ? \"#BB363F\" : \"#000\" }}\u003e Make our world colourful! \u003c/h1\u003e \u003cbutton className=\"StylePrac__button\" onClick={switchHandler}\u003eSwitch\u003c/button\u003e \u003c/div\u003e ); }; export default StylePrac; 여기서 관련된 코드 조각은 이 부분입니다. \u003ch1 style={{ color: isSwitched ? \"#BB363F\" : \"#000\" }}\u003e isSwitched가 true면 해당 문구를 로코코 레드에 해당하는 #BB363F 색으로, 그렇지 않으면 검은색으로 색칠됩니다. 만약 해당 문서의 기본 글꼴색이 검정색인 경우 다음과 같이 표현할 수도 있습니다. \u003ch1 style={{ color: isSwitched \u0026\u0026 \"#BB363F\" }}\u003e isSwitched 인 경우 로코코 레드 색상이 적용됩니다. ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:1:0","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"2. className을 동적으로 부여 인라인으로 스타일을 부여하는 경우 코드가 스타일에 집중되기 때문에 보기 힘듭니다. 클래스 속성을 동적으로 부여해 스타일을 관리하겠습니다. 이 경우는 템플릿 리터럴을 사용합니다. 클래스로 스타일을 관리할 것이니까, 먼저 해당 클래스 이름을 새롭게 만들면서 css를 작성해야겠죠. /* StylePrac.css */ /* 기본 색상인 검정색으로 지정합니다. */ .header-text { color: #000; } /* switched 클래스가 부여되면 아래 색상은 로코코 레드 색상이 적용됩니다. */ .switched { color: #BB363F; } JSX 코드는 다음과 같습니다. \u003ch1 className={`header-text ${isSwitched ? \"switched\" : \"\"}`}\u003e isSwitched가 true이면 해당 className은 “header-text switched\"가 되고, false면 “header-text\"만 남을 겁니다. 또한 다음과 같이 표현해도 같습니다. \u003ch1 className={`header-text ${isSwitched \u0026\u0026 \"switched\"}`}\u003e ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:2:0","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"3. CSS 모듈 사용 그냥 CSS를 사용하면 해당 클래스 네임의 스타일이 전역으로 적용되기 때문에 해당 컴포넌트에만 적용 가능한 스타일을 사용하는 것이 권장됩니다. CSS 클래스 컨벤션을 컴포넌트이름__클래스이름 과 같이 지정해줄 수도 있겠지만, 실수가 생길 수도 있죠. 따라서 해당 컴포넌트에 대응하는 스타일만을 적용하도록 해주는 여러가지 방법이 있습니다. 여기서는 CSS 모듈을 사용해보겠습니다. ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:3:0","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"1. module.css 파일 생성 CSS 파일을 CSS 모듈 파일로 만들어줍니다. 파일 확장자를 .css에서 .module.css로 바꾸어주기만 하면 됩니다. 다음과 같은 파일로 변경됩니다. 내용은 같습니다. 확장자면 바뀌네요. /* StylePrac.module.css */ .header-text { color: #000; } .switched { color: #BB363F; } ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:3:1","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"2. CSS module 불러오기 해당 컴포넌트의 자바스크립트 코드에서 해당 모듈을 불러옵니다. import React, { useState } from \"react\"; // 해당 불러오기 대신 // import \"./StylePrac.css\"; // CSS 모듈 파일을 불러와줍니다. import style from \"./StylePrac.module.css\" ... ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:3:2","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev"],"content":"3. style로 내부 속성 사용하기 style 을 불러왔기 때문에 먼저 style을 접근하고 내부에 있는 속성에 접근합니다. 각 스타일의 경우 JSX 내 자바스크립트 문법으로 표기해주어야 하므로 템플릿 리터럴을 사용합니다. 해당 표기에서는 다른 객체에 접근하는 것처럼 점 표기법(Dot Notation)과 대괄호 표기법(Bracket Notation) 모두 사용할 수 있습니다. 단, 스타일에서 사용하는 클래스 이름의 경우 케밥 케이스를 사용하는 경우가 많기 때문에, 상황에 맞게 대괄호 표기법을 사용해줍니다. 해당 JSX 코드 조각을 다음과 같습니다. // StylePrac.js ... \u003ch1 className={`${style[\"header-text\"]}${isSwitched \u0026\u0026 style[\"switched\"]}`}\u003e // style.switched와 같이 점 표기법으로 아래와 같이 표시하는 것도 동일합니다. // \u003ch1 className={`${style[\"header-text\"]} ${isSwitched \u0026\u0026 style.switched}`}\u003e 개발자 도구를 통해 해당 HTML을 확인해보면 해당 컴포넌트(여기서는 StylePrac.js)의 고유한 클래스 값이 적용된 것을 확인할 수 있습니다. 색상 네모 내부의 고유 값이 지정되었음을 확인할 수 있습니다. 해당 컴포넌트의 전체 코드는 다음과 같습니다. import React, { useState } from \"react\"; import style from \"./StylePrac.module.css\" const StylePrac = () =\u003e { const [isSwitched, setIsSwitced] = useState(false); const switchHandler = () =\u003e { setIsSwitced(!isSwitched); }; return ( \u003cdiv\u003e \u003ch1 className={`${style[\"header-text\"]}${isSwitched \u0026\u0026 style[\"switched\"]}`}\u003e Make our world colourful! \u003c/h1\u003e \u003cbutton className={style[\"StylePrac__button\"]} onClick={switchHandler}\u003eSwitch\u003c/button\u003e \u003c/div\u003e ); }; export default StylePrac; ","date":"2022-10-03","objectID":"/posts/2022/10/1003_react_style/:3:3","tags":["Frontend","React","짧게 쓰기"],"title":"[React] 리액트에서 동적으로 스타일 적용하기","uri":"/posts/2022/10/1003_react_style/"},{"categories":["Dev","Data Structure"],"content":" 입력 상자에 입력된 어절을 기반으로, 이전에 입력한 키워드를 자동으로 완성하는 방법을 알아봅니다. 자료구조 Trie을 통해 구현할 수 있죠. 제가 정말 잘 샀다 싶은 앱들이 몇 있는데요, 편한가계부 는 그 중 하나입니다. (iOS에서는) 문자를 기반으로 사용자의 결제 내역을 자동으로 저장해주고, 일정 기간별로 통계를 보여주어 지난 한 기간에서의 지출 내용을 통한 미래 지출 계획 설계, 자가 분석 (+ 반성) 등을 도와주는 앱입니다. 그리고 각 결제 내역을 입력할 때 세부 내용을 입력할 수 있는데, 단어 조각을 입력하면 사용자가 과거에 입력했던 기록을 기반으로 입력할 내용을 찾아줍니다. 이렇게요. 특히 내가 입력했던 내용 을 찾아 보여주기 때문에, 구구절절하게 기입했던 내용 역시 잘 기억해놨다가 알아서 입력해줍니다. 저는 내용을 자세하게 적는 편인데, 예를 들어 서브웨이 터키 6인치 위트 피클류 제외 음료 없이 이라고 적거든요. 그리고 서브웨이에 가면 보통 먹었던 메뉴를 먹고요. 그 때마다 저 20음절의 어구를 직접 입력하는 것이 아니라, 서브라는 2음절만 완성해도 해당 내용을 알아서 찾아 주기 때문에 정말 편리합니다. 이와 같이 사용자가 입력했던 내용을 기반으로 자동완성해주는 기능을 구현해보도록 하겠습니다. 여러가지 방법이 있겠지만 여기서는 Trie 자료구조를 활용해보려고 합니다. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:0:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"Trie. 단어를 빠르게 찾는 자료구조 트라이 인덱싱(trie indexing) 정보·통신 가변 크기의 키 값을 다룰 때 특히 유용한 인덱스 구조. 트라이는 키 값 전체가 아니라 그 일부에 의해 각 레벨의 분기가 결정되는 차수 m≥2인 트리를 의미하며, 분기 노드와 정보 노드라는 두 종류의 노드를 갖는다. ⇒규범 표기는 미확정이다. 출처: 우리말샘 | 네이버 국어사전 사전에는 어렵게 설명 되어있네요… Trie는 Tree 구조와 유사한 형태를 가지는 자료구조입니다. 우리말 규범 표기는 미확정이지만, 영미 문화권에서는 Tree구조와 구분하기 위해 [트라이]로 읽는 것이 일반적입니다. 이 글에서는 단어를 색인하는 목적의 Trie 자료구조에 한정해서 이야기 해봅시다. Trie는 트리 구조와 유사한 형태로, 각 노드는 로마자에서는 하나의 알파벳 기준으로 만들어지며, 하나의 노드는 다음의 노드의 키가 되는 형태로 이루어진 자료구조입니다. 구문으로 풀어 쓰면 어려워 보이지만, 그림으로 보면 더 쉽게 이해할 수 있습니다. Wikipedia. “Trie”. https://en.wikipedia.org/wiki/Trie 상단의 그림을 봐볼까요? Wikipedia의 Trie 항목에서 가져온 그림입니다. Trie는 일종의 사전입니다. 위의 Trie는 A, to, tea, ted, ten, inn의 총 6개 단어가 저장된 Trie입니다. 트리구조처럼 부모 노드가 자식 노드를 갖는 형태를 가지며, 각 단어의 바로 앞선 글자가 부모가 되며 그 다음 글자가 자식이 됩니다. 또한 맨 처음 노드인 head 는 비어있습니다. 상단 그림에서 3번으로 표기된 tea 를 기준으로 해당 자료구조를 설명해보겠습니다. 안내 다음의 Trie 구현은 하나의 예시일 뿐이며, 상황에 따라 다르게 사용됩니다. 본 코드에서는 Node에서 word라는 값을 사용했지만, 코드에 따라 boolean을 통해 해당 단어가 마지막인지 체크만하는 코드도 존재합니다. 각 글자(로마자의 경우 알파벳)의 경우 Node로 구성되어 있으며, 각 노드는 key, word, children으로 구성되어 있습니다. 구조를 설명하면서 완성된 단어라는 표현을 사용할 건데요, 이는 tea, ted, inn처럼 Trie에 입력되는 하나의 단어를 지칭하는 표현으로 사용하도록 하겠습니다. 먼저, 1. 최상단 부모노드 head 는 비어있습니다. 각 단어의 첫 글자는 head의 자식이 됩니다. 따라서, tea 의 첫 글자 t 는 head 의 자식이 됩니다. 노드를 기준으로 설명하면, head 노드의 key는 비어있는 노드이므로 언어에 따라 null 혹은 None 이 되고, children에는 노드 t 가 담기게 됩니다. 이 부분은 글로는 어렵지만, 아래 코드를 통해 본다면 훨씬 수월히 이해가 될 것입니다. 2. 바로 다음 글자는 앞선 글자의 자식이 됩니다. tea 의 첫 글자 t는 head의 자식인 노드가 되며 key 값으로 t라는 값을 가지게 됩니다. 두 번째 글자 e 는 첫 번째 글자인 t 의 자식이 됩니다. 또한 연쇄적으로 두 번째 글자 e는 세 번째 글자 a 의 부모가 됩니다. 노드 기준으로는 t 값을 key로 가지는 노드의 children 에 e 노드가 담기게 되고, 다시 e 를 key 로 가지는 노드는 a 노드를 children 에 담습니다. 추가적으로, 여기서 만들어진 Trie는 to 라는 단어를 가지고 있기 때문에, 그림의 7번을 보면 t는 또 다른 자식인 o를 갖는 것을 볼 수 있습니다. 3. 단어의 마지막 글자는 해당 글자가 완성되었다는 정보를 갖습니다. 완성된 단어의 마지막 글자는 해당 글자가 완성되었다는 정보를 가집니다. 노드의 관점에서 보면, 해당 노드의 word에 완성된 단어의 값을 넣습니다. 완성된 단어가 아닌 경우 각 노드의 word는 none 혹은 null 값을 가질 것이며, 해당 노드가 완성된 단어의 마지막 글자일 경우 word값으로 완성된 단어를 가질 것입니다. 여기서는 a노드의 word값에 tea라는 값이 담기게 됩니다. 노드의 word 값을 통해 해당 단어가 완성된 단어인지 즉, Trie에 이 단어가 입력이 되어있는지 판별하게 됩니다. 위의 그림을 기준으로 한다면 각 노드를 표현한 동그라미 안에 쓰여진 to, te, tea, ted 와 같은 값들이 이에 해당합니다. 다만 실제 코드에서는 완성된 단어가 아닐 경우 null 값을 넣어주고, 완성된 단어일 경우에만 해당 단어를 넣어줄 것입니다. 이 설명 역시 글로는 어렵지만, 코드를 본다면 명확히 이해가 될 것입니다. 만약 글로 해당 구조가 그려지는 분들 중 이런 의문을 가지는 분들이 있을 수 있겠습니다. “그냥 자식이 없는 노드를 기준으로 완성된 단어인지 판별하면 되는 거 아닌가?” 하지만 자식을 가지지 않는 노드가 해당 단어의 마지막 글자다라는 기준으로만 해당 글자가 완성된 단어의 마지막 글자인지 판별하게 된다면 다음과 같은 상황에서 놓치게 되는 단어들이 있을 수 있습니다. 가령 Trie에 tea 라는 단어와 tealeaf 라는 단어가 모두 포함 되어 있을 경우죠. 이 경우 a 노드는 word 에 완성된 단어인 tea 라는 가짐과 동시에 자식으로 l을 가지게 됩니다. 즉, 자식을 가지고 있는 노드지만 tea라는 완성된 단어의 마지막 노드가 되는 것이지요. 따라서 해당 노드가 자식을 가지지 않는다를 기준으로 해당 단어가 완성된 단어인가를 판별하는 것은 위험합니다. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:1:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"자 이제 코드로 봅시다! 역시 코드로 보는 게 빠르지요. 먼저 Javascript로 보도록 하겠습니다. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"1. class로 구현 // 각 단어의 글자가 담길 Node class Node { constructor(key, word = null) { // key는 각 단어의 알파벳 this.key = key; // word는 해당 key가 단어의 마지막 글자일 경우 해당 단어를 담아줍니다. // 따라서 처음 값은 null this.word = word; // children의 Object에는 자식이 되는 글자를 key로, value에는 Node를 담아줍니다. this.children = {}; } } class Trie { constructor() { // 처음 생성되는 노드인 헤드는 key 값이 비어있는 노드입니다. this.head = new Node(null); } // insert는 해당 Trie에 단어를 담는 메소드입니다. // Trie.insert(\"tea\");와 같은 형태로 Trie에 단어를 담아줍니다. insert(string) { // 위에서 보았던 그림과 같이 순차적으로 노드를 탐색합니다. // 첫 노드는 head가 됩니다. // string이 'tea'일 경우, 첫 노드는 head, 그 다음 노드는 t, 그 다음은 e이며 마지막 노드는 a일 것입니다. let currNode = this.head; // string(단어)의 각 글자를 하나하나 탐색하며 Node에 담아줍니다. for (const char of string) { // 해당 글자가 children에 처음 담기는 글자일 경우 새로운 노드를 만들어 넣어줍니다. /* * 가령 이 Trie에 'to'를 insert하고 'tea'를 insert 했다면 * 'to'의 't'는 처음 입력되는 값이므로 아래 if문에 걸려 new Node가 작동할 것이지만 * 두 번째 입력된 'tea'의 't'는 head의 자식으로 이미 존재하기 때문에 아래 가정문에 걸리지 않을 것입니다. */ if (!(char in currNode.children)) { // 현재 노드에 처음으로 생성된 자식이라면 char를 key로 하는 새로운 노드를 만들어 Object에 넣습니다. currNode.children[char] = new Node(char); } // 자식 노드를 현재 노드로 바꾸어 주고 다음 for-loop를 시행합니다. currNode = currNode.children[char]; } // for-loop가 종료되었다면, 즉 해당 currNode(현재 노드)가 마지막 글자가 되었다면, word값을 null이 아닌 string(완성된 단어)을 입력해줍니다. // 'tea'라는 단어를 insert 했다면 'a' 노드만 word 값으로 'tea'를 가지고, 't'와 'a'의 word는 null일 것입니다. currNode.word = string; } // Trie에 string이라는 값이 있는지 탐색하는 메소드입니다. search(string) { // 첫 시작노드는 head가 됩니다. let currNode = this.head; // 찾고자 하는 단어의 각 글자(로마자의 경우 알파벳)을 기준으로 하나하나 탐색합니다. for (const char of string) { // 현재 노드의 자식으로 다음 글자가 존재한다면 if (char in currNode.children) { // 다음 노드는 현재 노드로 바꾸어 줍니다. currNode = currNode.children[char]; // 다음 글자가 현재 노드의 자식으로 존재하지 않는다면 } else { // 찾고자 하는 단어가 없는 것이므로 false를 반환합니다. return false; } } // for-loop가 무사히 종료되어 마지막 노드가 현재 노드(currNode)가 됐을 경우 // 현재 노드의 word가 찾고자 하는 단어와 같다면 if (currNode.word === string) { // 해당 단어는 본 Trie에 포함되어있다는 의미의 true를 반환합니다. return true; // 그렇지 않은 경우는 해당 단어가 Trie에 없는 경우이므로 false를 반환합니다. /* * 예를 들어 Trie에 'tealeaf'라는 단어가 포함되어있지만 'tea'라는 단어가 포함되어있지 않은 경우라면 * 'tea'라는 단어를 해당 Trie에서 찾을 경우, for-loop는 무사히 수행하지만 * 해당 Trie에는 존재하지 않는 단어입니다. */ } else { // 따라서 해당 단어는 본 Trie에 포함되어있지 않으므로 false를 반환합니다. return false; } } } ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:1","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"2. function으로 구현 // 각 주석은 위의 class 코드에 적힌 주석과 똑같습니다. // 각 단어의 글자가 담길 Node const Node = function(key, word = null) { // key는 각 단어의 알파벳 this.key = key; // word는 해당 key가 단어의 마지막 글자일 경우 해당 단어를 담아줍니다. // 따라서 처음 값은 null this.word = word; // children의 Object에는 자식이 되는 글자를 key로, value에는 Node를 담아줍니다. this.children = {}; } const Trie = function() { // 처음 생성되는 노드인 헤드는 key 값이 비어있는 노드입니다. this.head = new Node(null); // insert는 해당 Trie에 단어를 담는 메소드입니다. // Trie.insert(\"tea\");와 같은 형태로 Trie에 단어를 담아줍니다. this.insert = function(string) { // 위에서 보았던 그림과 같이 순차적으로 노드를 탐색합니다. // 첫 노드는 head가 됩니다. // string이 'tea'일 경우, 첫 노드는 head, 그 다음 노드는 t, 그 다음은 e이며 마지막 노드는 a일 것입니다. let currNode = this.head; // string(단어)의 각 글자를 하나하나 탐색하며 Node에 담아줍니다. for (const char of string) { // 해당 글자가 children에 처음 담기는 글자일 경우 새로운 노드를 만들어 넣어줍니다. /* * 가령 이 Trie에 'to'를 insert하고 'tea'를 insert 했다면 * 'to'의 't'는 처음 입력되는 값이므로 아래 if문에 걸려 new Node가 작동할 것이지만 * 두 번째 입력된 'tea'의 't'는 head의 자식으로 이미 존재하기 때문에 아래 가정문에 걸리지 않을 것입니다. */ if (!(char in currNode.children)) { // 현재 노드에 처음으로 생성된 자식이라면 char를 key로 하는 새로운 노드를 만들어 Object에 넣습니다. currNode.children[char] = new Node(char); } // 자식 노드를 현재 노드로 바꾸어 주고 다음 for-loop를 시행합니다. currNode = currNode.children[char]; } // for-loop가 종료되었다면, 즉 해당 currNode(현재 노드)가 마지막 글자가 되었다면, word값을 null이 아닌 string(완성된 단어)을 입력해줍니다. // 'tea'라는 단어를 insert 했다면 'a' 노드만 word 값으로 'tea'를 가지고, 't'와 'a'의 word는 null일 것입니다. currNode.word = string; } // Trie에 string이라는 값이 있는지 탐색하는 메소드입니다. this.search = function(string) { // 첫 시작노드는 head가 됩니다. let currNode = this.head; // 찾고자 하는 단어의 각 글자(로마자의 경우 알파벳)을 기준으로 하나하나 탐색합니다. for (const char of string) { // 현재 노드의 자식으로 다음 글자가 존재한다면 if (char in currNode.children) { // 다음 노드는 현재 노드로 바꾸어 줍니다. currNode = currNode.children[char]; // 다음 글자가 현재 노드의 자식으로 존재하지 않는다면 } else { // 찾고자 하는 단어가 없는 것이므로 false를 반환합니다. return false; } } // for-loop가 무사히 종료되어 마지막 노드가 현재 노드(currNode)가 됐을 경우 // 현재 노드의 word가 찾고자 하는 단어와 같다면 if (currNode.word === string) { // 해당 단어는 본 Trie에 포함되어있다는 의미의 true를 반환합니다. return true; // 그렇지 않은 경우는 해당 단어가 Trie에 없는 경우이므로 false를 반환합니다. /* * 예를 들어 Trie에 'tealeaf'라는 단어가 포함되어있지만 'tea'라는 단어가 포함되어있지 않은 경우라면 * 'tea'라는 단어를 해당 Trie에서 찾을 경우, for-loop는 무사히 수행하지만 * 해당 Trie에는 존재하지 않는 단어입니다. */ } else { // 따라서 해당 단어는 본 Trie에 포함되어있지 않으므로 false를 반환합니다. return false; } } } 기본적인 코드는 이렇게 됩니다. 사용은 어떻게 하면 되는지 아래에서 보여드릴게요. 코드에 대한 내용은 주석을 참고해주세요. 위 코드는 주석이 많으니까 복붙해서 쓰시려는 분들은 아래 코드를 사용해주세요. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:2","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"3. 기본적인 사용 예시 const Node = function(key, word = null) { this.key = key; this.word = word; this.children = {}; } const Trie = function() { this.head = new Node(null); this.insert = function(string) { let currNode = this.head; for (const char of string) { if (!(char in currNode.children)) { currNode.children[char] = new Node(char); } currNode = currNode.children[char]; } currNode.word = string; } this.search = function(string) { let currNode = this.head; for (const char of string) { if (char in currNode.children) { currNode = currNode.children[char]; } else { return false; } } if (currNode.word === string) { return true; } else { return false; } } } // 간단한 사용 예시 코드 // new 키워드를 사용해 생성자 함수 만들기 const trie = new Trie(); // 이 단어들을 Trie에 넣어주도록 해볼게요. const stringArr = [\"apple\", \"apollo\", \"apptite\", \"appstore\", \"appdulla\"]; stringArr.forEach(string =\u003e { // 만들어진 trie에 insert 메소드를 통해 단어들을 넣습니다. trie.insert(string); }) // apple이라는 값이 이 trie에 있니? console.log(\"apple: \", trie.search(\"apple\")); // true // apollo는? console.log(\"apollo: \", trie.search(\"apollo\")); // true // 혹시 apgujeong도? console.log(\"apgujeong: \", trie.search(\"apgujeong\")); // false 이렇게 사용하면 됩니다. 역시 결과값으로 보니까 훨씬 낫네요. ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:2:3","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"Trie를 활용해 자동완성 입력창 만들기 이제 Trie를 어느정도 쓸 수 있을 것 같으니까 실제 기능구현으로 활용해봅시다. 사용자가 입력한 값을 저장하고, 이 값을 자동완성해주는 기능을 구현해보겠습니다. 다음과 같은 입력상자가 있고 아래에 자동 완성이 되도록 만들어보겠습니다. 고맙게도 입력한 값을 기준으로 잘 나타나고 있네요. 참고로 로마자는 알파벳 기준으로 하나의 노드가 완성되지만, 한글의 경우는 완성된 하나의 음절 혹은 따로 떨어져 입력된 자소 단위로 노드가 완성됩니다. 따라서 o(이응)과 아는 전혀 상관없는 별개의 노드가 되고, o(이응)은 아의 부모노드가 되지 않습니다. 기존의 코드와는 다르게, 단어가 완성되지 않았을 때 완성될 것으로 예상되는 단어들을 보여주어야 합니다. 따라서 search() 메소드를 조금 수정했습니다. 코드는 다음과 같습니다. \u003c!-- index.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003c/head\u003e \u003cbody\u003e \u003cmain class=\"App\"\u003e \u003c/main\u003e \u003cscript src=\"trie.js\" \u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e // trie.js const $app = document.querySelector(\".App\"); const $inputBox = document.createElement(\"input\"); $app.appendChild($inputBox); const $textBox = document.createElement(\"p\"); $app.appendChild($textBox); const Node = function(key, word = null) { this.key = key; this.word = word; this.children = {}; } const Trie = function() { this.head = new Node(null); this.insert = function(string) { let currNode = this.head; for (const char of string) { if (!(char in currNode.children)) { currNode.children[char] = new Node(char); } currNode = currNode.children[char]; } currNode.word = string; } this.search = function(string) { let currNode = this.head; for (const char of string) { if (char in currNode.children) { currNode = currNode.children[char]; } else { return; } } // 현재 입력한 값을 기준으로 만들 수 있는 단어들을 넣어줍니다. let foundWords = []; // 재귀함수를 통해 현재 단어를 기준으로 만들 수 있는 단어들을 찾습니다. const recurSearch = (currNode) =\u003e { // 현재 노드에 완성된 단어가 있고 if (currNode.word) { // 찾은 단어가 아직 배열에 들어있지 않다면, 해당 단어를 삽입해줍니다. if (!(currNode.word in foundWords)) { foundWords = [ ...foundWords, currNode.word ]; } } // 현재 노드 기준으로 자식 단어를 찾습니다. for (const child in currNode.children) { recurSearch(currNode.children[child]); } } recurSearch(currNode); return foundWords; } } const trie = new Trie(); // 출력된 내용을 보여주는 코드 $inputBox.addEventListener(\"keyup\", e =\u003e { $textBox.innerHTML = null; if (e.target.value) { const results = trie.search(e.target.value); if (results) { $textBox.innerHTML = results.map(result =\u003e `\u003cp class=\"result\"\u003e${result}\u003c/p\u003e`).join(\"\") } } if (e.key === \"Enter\" \u0026\u0026 e.target.value) { trie.insert(e.target.value); $inputBox.value = null; } }) ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:3:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"Debouncing을 활용, 입력완료까지 기다렸다가 자동완성하기 입력과 동시에 자동완성을 하는 것이 아니라, 사용자의 입력이 완료되었다고 판단한 후에 자동완성을 보여주는 것이 더 보기 좋을 것 같은데 한 번 해볼까요? Debouncing을 통해 구현할 수 있습니다! 아까와는 다르게 문구가 입력된 후 일정 시간이 지났을 때만 자동완성이 노출되도록 했습니다. 오 뭔가 조금 더 깔끔해진 기분이 듭니다. Debouncing에 관한 자세한 설명은 해당 링크를 참조해주세요. Debouncing을 적용한 코드는 다음과 같습니다. const $app = document.querySelector(\".App\"); const $inputBox = document.createElement(\"input\"); $app.appendChild($inputBox); const $textBox = document.createElement(\"p\"); $app.appendChild($textBox); // Debouncing을 합니다! const debounce = (func, delay) =\u003e { let debounceTimer; return function() { const context = this; const args = arguments; clearTimeout(debounceTimer); debounceTimer = setTimeout(() =\u003e func.apply(context, args), delay); } } const Node = function(key, word = null) { this.key = key; this.word = word; this.children = {}; } const Trie = function() { this.head = new Node(null); this.insert = function(string) { let currNode = this.head; for (const char of string) { if (!(char in currNode.children)) { currNode.children[char] = new Node(char); } currNode = currNode.children[char]; } currNode.word = string; } this.search = function(string) { let currNode = this.head; for (const char of string) { if (char in currNode.children) { currNode = currNode.children[char]; } else { return; } } let foundWords = []; const recurSearch = (currNode) =\u003e { if (currNode.word) { if (!(currNode.word in foundWords)) { foundWords = [ ...foundWords, currNode.word ]; } } for (const child in currNode.children) { recurSearch(currNode.children[child]); } } recurSearch(currNode); return foundWords; } } const trie = new Trie(); $inputBox.addEventListener(\"keyup\", e =\u003e { $textBox.innerHTML = null; if (e.key === \"Enter\" \u0026\u0026 e.target.value) { trie.insert(e.target.value); $inputBox.value = null; } }) // Debouncing을 적용합니다! // 350ms를 기준으로 입력했습니다. $inputBox.addEventListener(\"keyup\", debounce(e =\u003e { if (e.target.value) { const results = trie.search(e.target.value); if (results) { $textBox.innerHTML = results.map(result =\u003e `\u003cp class=\"result\"\u003e${result}\u003c/p\u003e`).join(\"\") } } }, 350)) 지연을 주고 출력하고 싶다면, 다음과 같이 디바운싱을 활용할 수 있습니다. 지연시간을 조절하면서 목적에 맞도록 구현하면 좋을 것 같네요.😄 ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:3:1","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev","Data Structure"],"content":"마치며 해당 포스트를 작성하며 찾아보았는데, 자동완성을 구현하는 방법은 많습니다. 특정 라이브러리나 브라우저의 자동완성 기능을 활용할 수도 있고요. 본 포스트에서는 Trie 자료구조에 대해 알아보고, 이를 활용할 수 있는 하나의 예시로 자동완성에 적용해보았습니다. Trie 자료구조의 시간복잡도는 문자열 길이 m에 대해 O(m) 입니다. 다만 문자열이 공간을 많이 차지하여, 공간 복잡도는 매우 크게 나타날 수 있습니다. Trie 구조 역시 상황에 따라 필요하다고 생각될 때 올바르게 사용하는 것이 중요할 것 같습니다.🤔 ","date":"2022-05-30","objectID":"/posts/2022/05/0530_trie_autocomplete/:4:0","tags":["Javascript"],"title":"[자료구조] Trie를 활용한 단어 색인과 자동완성 구현하기","uri":"/posts/2022/05/0530_trie_autocomplete/"},{"categories":["Dev"],"content":" 사용자의 입력을 기다렸다가 완전히 입력이 종료되었다고 판단되면 입력을 받도록 합니다. 디바운싱을 활용해서요. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:0:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"디바운싱이란? 사용자의 입력을 받아 처리해야 합니다. 단, 사용자의 모든 입력이 종료되었을 때만 입력을 받고 엔터 키를 누르는 등 입력이 종료되었다는 별도의 액션이 없습니다. 사용자의 입력이 완료 되었음을 어떻게 알고 처리할 수 있을까요? 간단해보이지만 실제로 구현하고자 하면 생각보다 쉽지 않을 것입니다. 이러한 문제를 해결하기 위한 개념이 deboucing 입니다. 디바운싱(debouncing) 기계식 스위치의 동작을 전기적 신호로 바꿀 때 생기는 진동 잡음을 제거하기 위하여 사용하는 하드웨어의 지연 회로, 소프트웨어의 적절한 지연 시간. 출처 : 컴퓨터 인터넷 IT용어 대사전 | 네이버 사전 사전에서는 목적에 맞는 처리를 위한 소프트웨어의 적절한 지연 시간을 디바운싱이라고 정의하고 있습니다. 디바운싱이 필요한 경우는 어떤 경우이며, 또 어떻게 적용해야 할까요? 제가 디바운싱을 통해 문제를 해결했었던 경험을 통해 디바운싱에 대해 이야기 해볼까 합니다. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:1:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"문제상황. ‘RFID 코드 입력을 처리해야하는데…’ 화면에서 RFID 번호를 입력을 받아야 했습니다. RFID란 간단히 말하자면 식별이 가능한 태그입니다. 바코드와 비슷한데, 교통카드처럼 접촉으로 인식하며 상품의 종류 뿐 아니라 각 상품 하나를 인식하며 관리하기 위해 쓰이는 게 보통입니다. 가령 바코드는 \"삑! 이건 사과, 삑! 이건 바나나\"로 인식한다면, RFID는 \"삑! 이건 어제 네 번째로 들어온 청송사과, 삑! 이건 어제 첫 번째로 들어온 충주사과\" 이런 식이죠. 바코드와는 다르게 각 상품에 1:1로 매칭이 되는 것이지요. 요런 식으로 제품에 붙어있답니다.여기 붙어있는 RFID 값은 저희 집 찬장 구석에 내용물은 모두 내어주고 병만 남은 이 잭다니엘에게만 주어진 고유한 값이죠 자, 그래서 프로젝트 진행 중 RFID 코드를 입력받아야 했습니다. RFID 리더기를 사용해 RFID 태그의 입력을 받았죠. RFID 리더기나 바코드 인식기 등, 입력을 받는 기기들은 보통 입력 값을 입력해주고 자동으로 엔터를 자동으로 입력해 처리해줍니다. 그러나 RFID 리더기를 통해서 상품을 읽히는데 예상과는 다르게 입력이 되었습니다. 기대했던 작동 방식 (희망편): RFID 태그를 리더기에 인식 -\u003e RFID 번호 값이 입력된 후 자동으로 엔터 입력 -\u003e 원하는 로직 처리 -\u003e RFID 리더기에 새로운 태그 인식 (반복) 실제 작동한 방식 (절망편): RFID 태그를 리더기에 인식 -\u003e 바로 엔터가 입력되지 않고 근처에 있는 RFID 코드 값이나 방금 인식된 값이 또 입력 -\u003e 엔터 입력 -\u003e 로직 처리 중, 그러나 그 와중에도 입력되고 있는 RFID 번호 -\u003e (서비스) ‘아 잠깐만여 이 번호는 또 뭐여’ -\u003e 그 와중에도 입력되고 있는 RFID -\u003e 으어어 (반복) 이런 상황이 발생하고 있었고 실제로 입력된 값들은 다음과 같았습니다. 기대했던 입력값: AAA00000000001 (엔터) -\u003e AAA00000000002 (엔터) -\u003e A000000000003 (엔터) 실제 입력값: AAA00000000001AAA00000000002A00000000 (엔터) 두 개의 온전한 RFID 번호와 불온전한 번호 하나가 결합한 형태 문제를 요약하자면, 하나의 입력 값을 받고 바로 엔터처리가 되지 않음 다른 RFID 태그가 근처에 있으면 같이 입력됨 혹은, 방금 태그한 RFID 태그가 다시 입력 됨 엔터가 입력되고 로직이 처리되는 과정에서 RFID 값이 또 입력 돼, 끝까지 인식되지 않은 RFID 입력 값이 발생 다음의 네 가지와 같았습니다. 따라서 입력이 완료 되었다고 판단 되었을 때 로직을 실행할 것, 입력된 RFID 중 중복 값을 제거하고 올바른 RFID만 모아 처리할 것 의 두 가지 해결 목표가 생겼습니다. ‘흠, 그렇다면 먼저 첫 번째 목표인 입력이 완료되었을 때... 를 어떻게 판별하고 처리해야할까…‘의 고민 중 문제해결 방법을 찾았고 디바운싱을 적용한다면 이 문제를 해결할 수 있다는 것을 알게 되었습니다. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:2:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"디바운싱. Javascript로 구현하기 Javascript 코드를 통해 디바운싱을 구현해봅시다. 사실 자바스크립트의 라이브러리 lodash 에서 debounce 메소드를 통해 손쉽게 디바운싱을 사용할 수 있습니다. 코드 원소스: https://www.geeksforgeeks.org/lodash-_-debounce-method/ // 출처: GeeksforGeeks // Requiring lodash library const _ = require('lodash'); // Using _.debounce() method // with its parameters var debounce_fun = _.debounce(function () { console.log('Function debounced after 1000ms!'); }, 1000); debounce_fun(); 여기서는 lodash의 도움을 구하지 않고 직접 코드를 써서 사용해볼까요. 코드 원소스: https://www.geeksforgeeks.org/debouncing-in-javascript/?ref=gcse // 출처: GeeksforGeeks const debounce = (func, delay) =\u003e { let debounceTimer return function() { const context = this const args = arguments clearTimeout(debounceTimer) debounceTimer = setTimeout(() =\u003e func.apply(context, args), delay) } } clearTimeout() 메소드는 이전에 생성되어 사용된 setTimeout() 을 취소하는 메소드입니다. 디바운싱 함수는 클로저를 이용한 형태로 만들어져있습니다. 따라서 함수 debounce의 실행 컨텍스트가 종료된 뒤에도 선언된 변수 debouncerTimer 는 사라지지 않고, setTimeout의 delay 시간이 남아있는 상태에서 또 다시 setTimeout의 delay 시간만큼 실행하고자 하는 함수 func를 기다리는 대상이 됩니다. 해당 내용은 기회가 된다면 따로 다루는 것이 좋겠네요. 간단하게 디바운싱이 작동하는 페이지를 만들어 봅시다. input 상자가 있고, 상자에 입력하는 문구가 하단에 기입이 되게 할 것입니다. 텍스트의 입력을 기다리고, 입력이 완료됐다고 판단되면 텍스트가 출력되는 디바운싱을 구현해봅니다. 실제는 이렇게 작동합니다. 입력이 완료될 때까지 잘 기다리고 있다가 작동하네요. 상황에 따라서 실시간으로 입력을 받거나, 디바운싱을 받거나 선택해서 사용하면 되겠지요. 코드는 다음과 같습니다. \u003c!-- index.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003c/head\u003e \u003cbody\u003e \u003cmain class=\"App\"\u003e \u003c/main\u003e \u003cscript src=\"debounce.js\" \u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e // debounce.js const $app = document.querySelector(\".App\") const $inputBox = document.createElement(\"input\") $app.appendChild($inputBox) const $textBox = document.createElement(\"p\") $app.appendChild($textBox) // 실제 Debouncing 관련 코드 const debounce = (func, delay) =\u003e { let debounceTimer return function() { const context = this const args = arguments clearTimeout(debounceTimer) debounceTimer = setTimeout(() =\u003e func.apply(context, args), delay) } } // 500ms의 지연시간을 준 debouncing $inputBox.addEventListener(\"keydown\", debounce(e =\u003e { $textBox.innerHTML = e.target.value }, 500)) 입력 지연시간은 실제로 서비스에 적용하면서 가장 적절한 값을 찾는 게 좋겠네요. 200, 300ms 혹은 여유있게 1초(1000ms)를 지연하는 것도 상황에 따라 괜찮을 것 같습니다. 다음과 같은 디바운싱으로 RFID 리더기의 입력 값을 기다리고 모든 인식이 끝났을 때 문자열을 입력, 처리해주어 로직을 처리함으로써 문제를 해결할 수 있었습니다. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:3:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"+) 비교: Debouncing이 적용되지 않은 경우 디바운싱이 적용되지 않은 경우는 다음과 같습니다. 사용자의 입력이 끝나기도 전에, 입력이 될 때마다 함수가 작동하는 것을 알 수 있죠. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:3:1","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":["Dev"],"content":"후일담. 그래서 실제로는 이렇게 적용했어요 디바운싱을 적용해 이제는 불완전한 RFID 번호가 들어오거나, RFID 번호가 들어오고 있는 와중에 의도치 않은 함수가 실행되는 일은 없어졌습니다. 따라서 입력된 값들만 제대로 처리할 수 있게 가공해주기만 하면 끝이었죠. 남아 있는 문제는 다음과 같았습니다. 입력된 값은 유효한 RFID 하나의 값, 혹은 다수의 RFID의 값이 포함된 값일 수 있다. 입력된 RFID 번호는 같은 값이 중복되어 입력될 수 있다. 실제로 입력된 값의 유형은, 하나의 RFID 번호 ABCDE00000000001 혹은 ABCDE00000000002 와 같은 형태 다수의 RFID 번호 ABCDE00000000001ABCDE00000000002ABCDE00000000003 과 같은 형태 혹은 ABCDE00000000001ABCDE00000000002ABCDE00000000001 과 같이 일부 중복된 형태 다음의 두 가지였습니다. RFID 번호는 각기 고유한 규격을 가지고 있습니다. 각 RFID 번호는 고유한 길이, 첫 문자부터 일정 길이까지 정해진 값, 특정 값을 가진 분류 값 등 특정 문자열 패턴을 가지고 있고 유효한 값을 분리해줄 수 있었습니다. 따라서 1. 유효한 RFID 값인가의 경우는, 어차피 별로 길지 않은 문자열이기에 문자열의 글자를 하나하나 탐색하여 길이, 문자에 올바른 위치에 고유번호가 존재하는가(slice 활용) 등으로 해결할 수 있었습니다. 아니면 정규식 을 통해 해결할 수 있는 방법도 있겠죠. 2. 중복된 값이 있는가는 그냥 RFID의 값으로 인식된 값들을 하나 씩 Set()에 넣어주어 해결했습니다. 간단하죠! 이렇게 입력의 지연이 필요한 곳에 디바운싱을 적용하고 목표했던 서비스를 만들 수 있었습니다. 여러분도 입력의 완료 후 서비스의 작동이 필요하다면 디바운싱을 활용해 보세요. ","date":"2022-05-24","objectID":"/posts/2022/05/0520_debounce/:4:0","tags":["Javascript"],"title":"[Javascript] 사용자의 입력 완료까지 기다리기 \"debouncing\"","uri":"/posts/2022/05/0520_debounce/"},{"categories":null,"content":"반갑습니다! 캐디스푼의 아이티 블로그에 오신 것을 환영합니다!! 개발과 IT/SW의 내용과 함께, 차를 비롯한 저를 이루고 있는 것들로 채워질 공간입니다. 이렇게 만나게 되어 반갑습니다! 🤗 ","date":"2021-10-16","objectID":"/posts/2021/10/%ED%99%98%EC%98%81%ED%95%A9%EB%8B%88%EB%8B%A4/:0:0","tags":null,"title":"환영합니다.","uri":"/posts/2021/10/%ED%99%98%EC%98%81%ED%95%A9%EB%8B%88%EB%8B%A4/"}]